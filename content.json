{"pages":[],"posts":[{"title":"1. 微服务介绍","text":"微服务介绍 一、为什么要用微服务？ 互联网应用的特点： 需求变化快 用户群体大 二、 什么是微服务？ 简单来说，微服务就是将一种单一应用程序拆分为一组小型服务的方法，拆分完成之后，每一个服务都运行在独立的进程中，服务之间采用轻量级的通信机制来沟通。SpringCloud 中采用基于 HTTP 的 RESTful API 三、微服务的优势 复杂度可控 独立部署 技术选型灵活 较好的容错性 较强的可扩展性 四、 Spring Cloud 核心特性 服务注册与发现 负载均衡 服务之间调用 容错、服务降级、断路器 消息总线 分布式配置中心 链路器","link":"/2022/04/16/1.%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/"},{"title":"2. 服务注册中心","text":"服务注册中心EurekaEureka 是 Spring Cloud 的注册中心，类似 Dubbo 中的 Zookeeper。 到底什么是注册中心？我们为什么要注册中心 在单体应用中, 所有的业务集中在一个项目中，调用过程是一条直线，不需要服务之间的中转，没有必要引入注册中心 项目越来越大，我们会将系统进行拆分。各个模块之间进行协作，模块之间的调用 会变得越来越复杂，模块之间存在强耦合。 为了解决服务之间的耦合，注册中心方案自然就出现了。 基于 REST 来实现服务的注册与发现。 Eureka 是 Spring Cloud最重要的核心组件。 Eureka 提供可视化的页面，可以方便的查看服务注册情况医技服务注册中心集群的运行情况。从图中可以看出,存在3个角色 Eureka Server 注册中心 Eureka Provider 服务提供者 Eureka Consumer 服务消费者 Eureka 环境搭建创建一个普通的 spring boot项目, 添加 Eureka 依赖 项目创建成功之后，在项目启动类上添加注解，表示项目是一个 Eureka Server 12345678910@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); }} 其中 @EnableEurekaServer 注解表示开启 Eureka 功能 123456789# 给单前服务取名spring.application.name=eureka# 端口号server.port=1111# 表示当前项目不要注册到中心上eureka.client.register-with-eureka=false# 表示是否从 Eureka Server 获取注册信息eureka.client.fetch-registry=false 配置完成后就可以启动了 Eureka 集群搭建使用了注册中心之后，所有的服务都需要通过服务注册中心来进行交互。服务的注册中心的稳定性就非常重要了。所以注册中心一般都是集群的形式。 Eureka 集群就是多个 实例，相互注册，互相同步数据，组成集群实例A实例B配置完成后 打包启动A 1java -jar .\\eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=a 启动B 1java -jar .\\eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=b 互相注册成功 Eureka 工作细节本身可以分为2大部分：Eureka Server 和 Eureka Client Eureka Server 服务注册，所有服务都注册到 Eureka Server 上来 提供注册表，注册表是所有注册上来服务的列表，Eureka Client调用服务时,需要获取注册表，一般来说，注册表会缓存下来。 无状态，Eureka Server 通过注册心跳机制，和 Eureka Client同步 客户端状态。 Eureka ClientEureka Client 用来简化 服务和 Eureka Server 之间的交互,自动拉取，更新以及缓存 Eureka Server 的信息。即使 Eureka Server 宕机了，依然能够获取想要调用服务的地址（地址可能不准确） 服务注册所谓 Eureka Server 只是一个业务上划分，其实本身也是一个 Eureka Client 。需要把自身的元数据暴露出去,比如 ip,端口 运行状态等 服务续约默认情况下,服务注册之后，Eureka Client 每隔 30s 就要向 Eureka Server 发送一条心跳消息。Eureka Server 90s 内 没有收到 Eureka Client的消息，就会认为 Eureka Client 下线，会从服务列表中移除。一般不建议修改。 12eureka.instance.lease-renewal-interval-in-seconds=30eureka.instance.lease-expiration-duration-in-seconds=90 服务下线Eureka Client 下线周，会主动发送消息 告诉 Eureka Server ,我要下线了 获取注册表信息Eureka Client 从 Eureka Server 上获取服务注册信息，缓存到本地。数据会定期更新。2个属性 1234# 是否准许获取注册表信息eureka.client.fetch-registry=true# 更新时间间隔eureka.client.registry-fetch-interval-seconds=30 Eureka 集群原理官方架构图 Eureka Server 之间通过 Replicte 同步数据，不同的Eureka Server 不区分主从节点，所有节点平等的。节点之间，通过 servceUrl 互相注册，形成集群 A –&gt; B –&gt; CA 也是 能够和 C同步，不建议","link":"/2022/04/16/2.%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"},{"title":"4. Consul 介绍","text":"Consul注册中心备选方案。Consul主要提供了 服务发现、服务隔离、服务配置等功能相比于 Eureka 和 zookeeper，Consul 配置更加一站式,因为内置了很多微服务的常见的需求：服务发现与注册,分布式一致性协议实现、健康检查、键值对存储、多数据中心等、不在需要第三方组件来实现这些功能。 一、安装Consul使用go 语言开发,需要安装下载 1weget https://releases.hashicorp.com/consul/1.11.4/consul_1.11.4_linux_amd64.zip 安装 直接解压即可 1unzip consul_1.11.4_linux_amd64.zip 启动(开发模式启动,地址是本地虚拟机地址) 1./consul agent -dev -ui -node=consul-dev -client=192.168.10.128 启动成功之后，在物理机可以访问（需要注意端口 8500开放） 二、Consul 使用创建 spring boot 项目添加依赖 开启服务发现功能 123456789@SpringBootApplication@EnableDiscoveryClientpublic class ConsulProviderApplication { public static void main(String[] args) { SpringApplication.run(ConsulProviderApplication.class, args); }} 添加相关consul配置 123456spring.application.name=consul-providerserver.port=2000#consul 相关配置spring.cloud.consul.host=192.168.10.128spring.cloud.consul.port=8500spring.cloud.consul.discovery.service-name=consul-provider 添加测试接口 1234567@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;hello&quot;; }} 项目启动,注册成功 三、Consul 集群使用为了区别增加端口打印 123456789@RestControllerpublic class HelloController { @Value(&quot;${server.port}&quot;) Integer port; @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;hello :&quot; + port; }} 对项目进行打包,在命令行执行命令,启动多个实例 123java -jar .\\consul-provider-0.0.1-SNAPSHOT.jar --server.port=2001java -jar .\\consul-provider-0.0.1-SNAPSHOT.jar --server.port=2000 查看 consul 管理界面，集群注册成功 四、consul 消费搭建环境 consul-consumer 创建成功后，添加一下配置 123456spring.application.name=consul-consumerserver.port=2005#consul 相关配置spring.cloud.consul.host=192.168.10.128spring.cloud.consul.port=8500spring.cloud.consul.discovery.service-name=consul-consumer 开启服务发现 1@EnableDiscoveryClient 提供一个服务调用方法 12345678910111213141516171819@RestControllerpublic class HelloController { @Autowired LoadBalancerClient loadBalancerClient; @Autowired RestTemplate restTemplate; @Bean RestTemplate getRstTemplate(){ return new RestTemplate(); } @GetMapping(&quot;/hello&quot;) public void hello(){ ServiceInstance choose = loadBalancerClient.choose(&quot;consul-provider&quot;); System.out.println(&quot;服务地址&quot; + choose.getUri()); System.out.println(&quot;服务名称&quot; + choose.getServiceId()); String forObject = restTemplate.getForObject(choose.getUri() + &quot;/hello&quot;, String.class); System.out.println(forObject); }}","link":"/2022/04/16/4.%20Consul/"},{"title":"RestTmplate","text":"RestTmplate 介绍RestTmplate 是从 sprng 3.0 开始 支持的 http 请求工具。提供常见 REST 请求方法模板：GET POST PUT DELETERestTmplate 实现了 RestOperation 接口，RestOperation定义了 RESTFUL 操作 声明式使用12345678@BeanRestTemplate restTemplateOne(){ return new RestTemplate();}@AutowiredRestTemplate restTemplate; GETgetForObject 返回的是一个对象，对象是返回的具体值。3种请求方式 getForEntity 返回是一个 ResponseEntity 1234567891011//1String s = restTemplateOne.getForObject(&quot;http://provider/hello?name={1}&quot;,String.class,&quot;test&quot;);//2Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;name&quot;,&quot;test&quot;);String s1 = restTemplateOne.getForObject(&quot;http://provider/hello?name={name}&quot;,String.class,map);//3String url = &quot;http://provider/hello?name=&quot; + &quot;test&quot;;URI url1 = URI.create(url);String s2 = restTemplateOne.getForObject(url1,String.class); POST123456789101112131415161718@GetMapping(&quot;/hello6&quot;) public String hello6(){ //1 key vaues 传递参数 MultiValueMap&lt;String,Object&gt; map = new LinkedMultiValueMap&lt;String,Object&gt;(); map.add(&quot;id&quot;,123); map.add(&quot;username&quot;,&quot;java&quot;); map.add(&quot;password&quot;,&quot;123&quot;); String url = &quot;http://provider/user1&quot;; User user = restTemplateTwo.postForObject(url,map,User.class); System.out.println(user); user.setId(456); String url2 = &quot;http://provider/user2&quot;; //2 json 传递参数 User user1 = restTemplateTwo.postForObject(url2,user,User.class); System.out.println(user1); return &quot;ok!!!&quot;; }","link":"/2022/04/20/RestTemplate%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"3. 服务注册与消费","text":"服务注册与消费一、服务注册微服务注册到 Eureka Server 上,这样其他服务需要调用该服务时,只需要从 Eureka Server 上查询服务的信息即可 创建一个 provider 作为服务提供者,创建项目时，选择 Eureka Client 依赖和 WEB依赖。这样服务创建成功后，简单配置一下 就可以使用了 在 propertires 中 配置项目注册地址 123spring.application.name=providerserver.port=1114eureka.client.service-url.defaultZone = http://localhost:1111/eureka 启动 Erueka Server 再启动 provider：注册成功！ 二、服务消费2.1 基本用法在provider 中提供一个 hello 接口 1234567@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;hello provider&quot;; }} 再创建一个 consumer项目，去消费 provider 提供的接口。consumer 只要能够获取到 provider 接口的地址，就需要 再 consumer 中写死地址，意味着服务之间的耦合度太高了 创建 consumer 项目，添加 web 和 eureka client 依赖项目创建后,添加配置信息 123spring.application.name=consumerserver.port=1115eureka.client.service-url.defaultZone = http://localhost:1111/eureka 实际调用写死路径 12345678910111213141516171819202122232425@RestControllerpublic class UseHelloController { @GetMapping(&quot;/hello1&quot;) public String hello1(){ HttpURLConnection con = null; URL url = null; try { url = new URL(&quot;http://localhost:1114/hello&quot;); con = (HttpURLConnection) url.openConnection(); if (con.getResponseCode() == 200) { BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream())); String s = br.readLine(); br.close(); return s; } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return &quot;xxxxxx&quot;; }} 从 Eureka 服务发现中 请求接口 12345678910111213141516171819202122232425262728293031@RestControllerpublic class UseHelloController { @Autowired DiscoveryClient discoveryClient; @GetMapping(&quot;/hello2&quot;) public String hello2(){ List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(&quot;provider&quot;); ServiceInstance instance = list.get(0); String ip = instance.getHost();//ip int port = instance.getPort();//端口 String Url = &quot;http://&quot; + ip + &quot;:&quot; +port + &quot;/hello&quot;; //从服务发现实例中获取地址 HttpURLConnection con = null; URL url = null; try { url = new URL(Url); con = (HttpURLConnection) url.openConnection(); if (con.getResponseCode() == 200) { BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream())); String s = br.readLine(); br.close(); return s; } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return &quot;xxxxxx&quot;; }} 注意 DiscoveryClient 查询的服务列表是一个集合，其中每一个项就是一个服务实例 2.2 升级改造Http 调用, 从 RestTemplate 实现 12345678910111213141516171819@BeanRestTemplate restTemplateOne(){ return new RestTemplate();}@AutowiredRestTemplate restTemplate;@GetMapping(&quot;/hello3&quot;)public String hello3(){ List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(&quot;provider&quot;); ServiceInstance instance = list.get(0); String ip = instance.getHost();//ip int port = instance.getPort();//端口 String Url = &quot;http://&quot; + ip + &quot;:&quot; +port + &quot;/hello&quot;; //从服务发现实例中获取地址 String s = restTemplate.getForObject(Url,String.class); return s;} 接下来 使用 Ribbon 实现负载均衡首先，我们需要给 RestTemplate 添加注解 12345678910111213141516@Bean@LoadBalancedRestTemplate restTemplateTwo(){ return new RestTemplate();}@Autowired@Qualifier(&quot;restTemplateTwo&quot;)RestTemplate restTemplateTwo;@GetMapping(&quot;/hello4&quot;)public String hello4(){ String s = restTemplateTwo.getForObject(&quot;http://provider/hello&quot;,String.class); return s;} 负载均衡时，提供的地址是模糊的地址。不能给具体的地址 会报错。模糊地址会自动被拦截，自动实现负载均衡 三、RestTmplateRestTmplate 是从 sprng 3.0 开始 支持的 http 请求工具。提供常见 REST 请求方法模板：GET POST PUT DELETERestTmplate 实现了 RestOperation 接口，RestOperation定义了 RESTFUL 操作 3.1 GETgetForObject 返回的是一个对象，对象是返回的具体值。3种请求方式 12345678910//1String s = restTemplateOne.getForObject(&quot;http://provider/hello?name={1}&quot;,String.class,&quot;test&quot;);//2Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;name&quot;,&quot;test&quot;);String s1 = restTemplateOne.getForObject(&quot;http://provider/hello?name={name}&quot;,String.class,map);//3String url = &quot;http://provider/hello?name=&quot; + &quot;test&quot;;URI url1 = URI.create(url);String s2 = restTemplateOne.getForObject(url1,String.class); getForEntity 返回是一个 ResponseEntity 3.2 POSTprovider 中提供2个POST接口，同时 POST 请求需要传递 json。需要创建 maven 项目 作为 commons 模块。模块被 provider 和 consummer 共同引用。这样就可以方便传递 JSON了 provider 提供2个 post 接口 12345678910@PostMapping(&quot;/user1&quot;)public User addUser1(User user){//传参是以 key/value return user;}@PostMapping(&quot;/user2&quot;)public User addUser2(@RequestBody User user){//传参是以 json return user;} consumer 调用接口 1234567891011121314151617@GetMapping(&quot;/hello6&quot;) public String hello6(){ //1 key vaues 传递参数 MultiValueMap&lt;String,Object&gt; map = new LinkedMultiValueMap&lt;String,Object&gt;(); map.add(&quot;id&quot;,123); map.add(&quot;username&quot;,&quot;java&quot;); map.add(&quot;password&quot;,&quot;123&quot;); String url = &quot;http://provider/user1&quot;; User user = restTemplateTwo.postForObject(url,map,User.class); System.out.println(user); user.setId(456); String url2 = &quot;http://provider/user2&quot;; //2 json 传递参数 User user1 = restTemplateTwo.postForObject(url2,user,User.class); System.out.println(user1); return &quot;ok!!!&quot;; } 接口调用成功 postForLocation：场景，执行一个 post 请求之后, 马上进行重定向，比如注册完成之后，马上重定向到登录页面登录。http请求状态码 302 provider 提供注册接口,注意这里的post接口 响应码一定是302 不然无效 注意：重定向的地址一定要写成绝对路径，不要写成相对路径，否则调用会出问题，找不到服务实例 123456789101112@Controllerpublic class RegisterController { @PostMapping(&quot;/register&quot;) public String register(User user){ return &quot;redirect:http://provider/loginPage?name=&quot; + user.getUsername(); } @GetMapping(&quot;/loginPage&quot;) @ResponseBody public String loginPage(String name){ return &quot;loginPage:&quot; + name; }} consummer 调用 123456789101112131415@Autowired@Qualifier(&quot;restTemplateTwo&quot;)RestTemplate restTemplateTwo;@GetMapping(&quot;/hello7&quot;)public String hello7(){ String url = &quot;http://provider/register&quot;; MultiValueMap&lt;String,Object&gt; map = new LinkedMultiValueMap&lt;String,Object&gt;(); map.add(&quot;id&quot;,123); map.add(&quot;username&quot;,&quot;java&quot;); map.add(&quot;password&quot;,&quot;123&quot;); URI uri = restTemplateTwo.postForLocation(url,map); String s = restTemplateTwo.getForObject(uri,String.class); return s;} 负载均衡原理 从 Eureka Cilent 本地缓存的服务注册信息中选择一个可以调用的服务 根据选中的服务，重构请求的 URL 地址 最终将功能嵌入到 RestTemplate 中","link":"/2022/04/16/3.%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B6%88%E8%B4%B9/"},{"title":"how to push","text":"每篇文章开头附上如下 12345678---title: 标题date: 时间点tags: 标签categories: 分类---截断全文 &lt;!-- more --&gt; ~\\source_posts 在此目录下 写文章 清除缓存 1hexo clean 生成静态文件 发布 12hexo ghexo s 发布到 github 1hexo d","link":"/2022/04/01/How%20to%20push/"},{"title":"http invoke webservice","text":"HttpClient 调用 webservice 服务12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 /** 具体的业务请求 */ public HISResult hisWebBusiness(HIS_Log log,String wsURL, String tranCode, String inXml) throws Exception { HISResult hr = new HISResult(); try { // time1 long time1 = System.currentTimeMillis(); log.setInXML(inXml); log.setTranCode(tranCode); StringBuffer xMLcontent = new StringBuffer(); xMLcontent.append(&quot;&lt;soapenv:Envelope xmlns:soapenv=\\&quot;http://schemas.xmlsoap.org/soap/envelope/\\&quot; xmlns:zls=\\&quot;ZLSoft\\&quot;&gt;\\n&quot;); xMLcontent.append(&quot;&lt;soapenv:Header/&gt;\\n&quot;); xMLcontent.append(&quot;&lt;soapenv:Body&gt;\\n&quot;); xMLcontent.append(&quot;&lt;zls:fRun&gt;\\n&quot;); xMLcontent.append(&quot;&lt;zls:TranCode&gt;&quot;); xMLcontent.append(tranCode); xMLcontent.append(&quot;&lt;/zls:TranCode&gt;\\n&quot;); xMLcontent.append(&quot;&lt;zls:InXml&gt;\\n&quot;); xMLcontent.append(&quot;&lt;![CDATA[&quot;); xMLcontent.append(inXml); xMLcontent.append(&quot;]]&gt;&quot;); xMLcontent.append(&quot;&lt;/zls:InXml&gt;\\n&quot;); xMLcontent.append(&quot;&lt;zls:OutXml&gt;\\n&quot;); xMLcontent.append(&quot;&lt;/zls:OutXml&gt;\\n&quot;); xMLcontent.append(&quot;&lt;/zls:fRun&gt;\\n&quot;); xMLcontent.append(&quot;&lt;/soapenv:Body&gt;\\n&quot;); xMLcontent.append(&quot;&lt;/soapenv:Envelope&gt;&quot;); String message = HTTPClientTypeXml(wsURL, xMLcontent.toString(), &quot;UTF-8&quot;); String outxml = getResultNode(message, &quot;OutXml&quot;); String xml = StringEscapeUtils.unescapeHtml(outxml); if (xml != null) { // 去除 CDATA xml = xml.replace(&quot;&lt;![CDATA[&quot;, &quot;&quot;); xml = xml.replace(&quot;]]&gt;&quot;, &quot;&quot;); // 去除前言 xml = xml.replace(&quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt;&quot;,&quot;&quot;); // 去除空格 xml = xml.trim(); } log.setOutXML(xml); hr.setOutXml(xml); long time2 = System.currentTimeMillis(); long time3 = time2 - time1; hr.setJksj((int) time3); } catch (Exception e) { log.setOutXML(e.getMessage()); throw e; }finally{ logDao.saveHI_LOG(log); } return hr;}/** 对 xml 出参截取工具 */ private String getResultNode(String responseMsg,String node){ if (responseMsg == null &amp;&amp; &quot;&quot;.equals(responseMsg)) { return responseMsg; } responseMsg = responseMsg.replaceAll(&quot;&amp;lt;&quot;, &quot;&lt;&quot;); responseMsg = responseMsg.replaceAll(&quot;&amp;gt;&quot;, &quot;&gt;&quot;); responseMsg = responseMsg.replaceAll(&quot;&gt; &lt;&quot;, &quot;&gt;&lt;&quot;); responseMsg = responseMsg.replaceAll(&quot;\\n&quot;, &quot;&quot;); responseMsg = responseMsg.replaceAll(&quot;\\r&quot;, &quot;&quot;); String begin = &quot;&lt;&quot;+node+&quot;&gt;&quot;; String end = &quot;&lt;/&quot;+node+&quot;&gt;&quot;; String regex = begin + &quot;(.*)&quot; + end; Pattern p = Pattern.compile(regex); Matcher m = p.matcher(responseMsg); if (m.find()) { responseMsg = m.group(1); } return responseMsg;} /** HTTP 调用方法工具 */ private String HTTPClientTypeXml(String wsurl,String request,String charset) throws Exception{ CloseableHttpClient httpClient = httpBulder.build(); HttpPost post = new HttpPost(wsurl); post.setHeader(&quot;Content-type&quot;, &quot;text/xml; charset=&quot;+charset); post.setConfig(requestConfig); StringEntity entity = new StringEntity(request, Charset.forName(charset)); entity.setContentEncoding(charset); // 发送xml格式的数据请求 entity.setContentType(&quot;text/xml&quot;); post.setEntity(entity); HttpResponse response = httpClient.execute(post); HttpEntity entity2 = response.getEntity(); String message = null; message = EntityUtils.toString(entity2, charset); return message;}","link":"/2022/04/20/http%E8%AF%B7%E6%B1%82webservice%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"spring 统一结果返回","text":"全局统一结果返回降低开发人员沟通成本，返回结果统一约定统一格式。 1. 定义状态码12345678910111213141516171819202122public enum ResultCode { RS200(200,&quot;操作成功&quot;), RS500(500,&quot;操作失败&quot;); // 自定义状态码 private final int code; // 自定义描述 private final String msg; ResultCode(int code, String msg){ this.code = code; this.msg = msg; } public int getCode() { return code; } public String getMsg() { return msg; }} 2. 定义返回对象123456789101112131415161718192021222324252627282930313233import lombok.Data;@Datapublic class BaseResult&lt;T&gt; { int code; long time; String msg; T body; public BaseResult(){ this.time = System.currentTimeMillis(); } public static &lt;T&gt; BaseResult&lt;T&gt; success(T body){ BaseResult result = new BaseResult(); result.setCode(ResultCode.RS200.getCode()); result.setMsg(ResultCode.RS200.getMsg()); result.setBody(body); return result; } public static &lt;T&gt; BaseResult&lt;T&gt; fail(){ BaseResult result = new BaseResult(); result.setCode(ResultCode.RS500.getCode()); result.setMsg(ResultCode.RS500.getMsg()); return result; } public static &lt;T&gt; BaseResult&lt;T&gt; fail(String msg){ BaseResult result = new BaseResult(); result.setCode(ResultCode.RS500.getCode()); result.setMsg(msg); return result; } 3. 全局ResponseBody 处理全局处理之前 要确定哪些地方用到，会不会存在不使用的情况 不使用全局返回 定义注解 1234567891011mport java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target({ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)public @interface Primitive {} 需要借助SpringBoot 提供的ResponseBodyAdvice即可。 ResponseBodyAdvice 的作用：拦截Controller方法的返回值，统一处理返回值/响应体，一般用来统一返回格式，加解密，签名等等。 supports表示是否需要处理，那么这里我们通过接口方法上是否有上一步定义的Primitive注解来判断； beforeObjectWrite方法表示具体的处理，body表示原有的方法返回值，这里我们对其包裹一层，就实现了统一的格式返回。 123456789101112131415161718192021222324252627282930313233343536373839import com.fasterxml.jackson.databind.ObjectMapper;import lombok.SneakyThrows;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.MethodParameter;import org.springframework.http.MediaType;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.server.ServerHttpRequest;import org.springframework.http.server.ServerHttpResponse;import org.springframework.web.bind.annotation.RestControllerAdvice;import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;import java.util.Objects;@RestControllerAdvice(basePackages = &quot;com.example.invoke&quot;)public class ResponseBodyWrapper implements ResponseBodyAdvice&lt;Object&gt; { @Autowired private ObjectMapper objectMapper; @Override public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) { return Objects.requireNonNull(returnType.getMethod()).getAnnotation(Primitive.class) == null; } @SneakyThrows @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { // 如果Controller直接返回String的话，SpringBoot是直接返回，故我们需要手动转换成json。备注：type：text/plain;charset=UTF-8 if(body instanceof String){ return objectMapper.writeValueAsString(BaseResult.success(body)); } // 如果对象已经是 BaseResult 直接返回即可 if (body instanceof BaseResult){ return body; } return BaseResult.success(body); }} TODO: 为什么 对于 STRING 类型 SpringBoot 是直接返回 ? spring 框架有个HttpMessageConverter类，就是专门用来处理流和接口的参数类型或返回值类型之间的转换的。方法也很好理解，就是判断能不能进行读操作，能的话就进行读操作；能不能进行写操作，能的话就进行写操作。 断点查看 发现这个converter是一个StringHttpMessageConverter类型，然后我们进入到addDefaultHeaders方法 代码执行到这里 发生 ClassCastException异常。 最后，我们终于找到了发生异常的原因，因为 260 的代码会执行getContentLength(t, headers.getContentType())这个方法，而这个方法会去执行StringHttpMessageConverter的getContentLength方法，如下图所示： 但是这个时候 t的类型已经被我们用beforeBodyWrite方法转为Result类型了，所以就发生了类型转换异常的错误。 建议使用这种方式 代替 手动转 json。这种 响应头是 application/json 12345678910111213141516171819import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.http.converter.StringHttpMessageConverter;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import java.util.List;@Configurationpublic class MyWebmvcConfiguration implements WebMvcConfigurer { @Override public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { // 1. 将 json 处理的转换器放到第一位，使得先让 json 转换器处理返回值，这样 String转换器就处理不了了。 converters.add(0, new MappingJackson2HttpMessageConverter()); //2. 删除springboot默认的StringHttpMessageConverter解析器 // converters.removeIf(x -&gt; x instanceof StringHttpMessageConverter); }} 4. 全局异常处理器 @RestControllerAdvice，RestController的增强类，可用于实现全局异常处理器 @ExceptionHandler,统一处理某一类异常，从而减少代码重复率和复杂度，比如要获取自定义异常可以 @ExceptionHandler(BusinessException.class) @ResponseStatus指定客户端收到的http状态码 1234567891011@Slf4j@RestControllerAdvicepublic class ResultExceptionHandler { @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public BaseResult&lt;String&gt; exception(Exception e){ log.error(&quot;全局异常信息 exception = {}&quot;,e.getMessage(),e); return BaseResult.fail(e.getMessage()); }} 编写 controller 1234567891011121314151617181920212223242526272829303132333435@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String sayHello(){ return &quot;123&quot;; } @GetMapping(&quot;/hello1&quot;) @Primitive public String sayHello2(){ return &quot;123&quot;; } @GetMapping(&quot;/hello2&quot;) public int sayHello22(){ return 1/0; } @GetMapping(&quot;/user&quot;) public User sayHello3(){ User user = new User(); user.setUsername(&quot;zhangsan&quot;); user.setPassword(&quot;123&quot;); return user; } @GetMapping(&quot;/user1&quot;) @Primitive public User sayHello4(){ User user = new User(); user.setUsername(&quot;zhangsan&quot;); user.setPassword(&quot;123&quot;); return user; }} 实际效果 1234567891011121314151617181920212223242526272829303132333435363738# hello{ &quot;code&quot;: 200, &quot;time&quot;: 1650780227306, &quot;msg&quot;: &quot;操作成功&quot;, &quot;body&quot;: &quot;123&quot;}# hello1123# hello2{ &quot;code&quot;: 500, &quot;time&quot;: 1650780285696, &quot;msg&quot;: &quot;/ by zero&quot;, &quot;body&quot;: null}# user{ &quot;code&quot;: 200, &quot;time&quot;: 1650778878610, &quot;msg&quot;: &quot;操作成功&quot;, &quot;body&quot;: { &quot;username&quot;: &quot;zhangsan&quot;, &quot;password&quot;: &quot;123&quot; }}# user1{ &quot;username&quot;: &quot;zhangsan&quot;, &quot;password&quot;: &quot;123&quot;}","link":"/2022/04/24/spring%20%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/"},{"title":"断路器","text":"Hystrix 介绍 初始化熔断器 每次调用之前检查服务状态 服务可用，继续执行逻辑 出现调用失败，记录失败次数,失败次数达到阈值，打开断路器 失败期间内，执行重试机制 重试成功测试达到阈值，关闭断路器，恢复业务 核心类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package cn.com.winning.bd.api.hystrix;import java.util.concurrent.CompletableFuture;import java.util.concurrent.TimeUnit;import java.util.function.Function;import java.util.function.Supplier;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * 核心 熔断器 * ClassName: CircuitBreaker * @Description: TODO * @date 2022年4月15日 */public class CircuitBreaker { private static final Logger logger = LoggerFactory.getLogger(CircuitBreaker.class); private HystrixStatus state; private final HystrixConfig config; private final HystrixCounter counter; private long lastOpenedTime; private String hystrixName;//熔断器名字 /** 业务超时时间 */ private int HYSTRIX_TIME_OUT = 2;//单位秒 public CircuitBreaker(HystrixConfig config,String HystrixName) { this.counter = new HystrixCounter(config.getFailureCount(), config.getFailureTimeInterval()); this.state = HystrixStatus.CLOSED; this.config = config; this.hystrixName = HystrixName; logger.info(&quot;熔断器名称&quot; + this.hystrixName); logger.info(&quot;业务超时时间：&quot; + this.HYSTRIX_TIME_OUT + &quot;s&quot;); logger.info(&quot;----------初始化配置信息结束---------------&quot;); } public CircuitBreaker(HystrixConfig config,String HystrixName,int HYSTRIX_TIME_OUT) { this.counter = new HystrixCounter(config.getFailureCount(), config.getFailureTimeInterval()); this.state = HystrixStatus.CLOSED; this.config = config; this.hystrixName = HystrixName; this.HYSTRIX_TIME_OUT = HYSTRIX_TIME_OUT; logger.info(&quot;熔断器名称&quot; + this.hystrixName); logger.info(&quot;业务超时时间：&quot; + this.HYSTRIX_TIME_OUT + &quot;s&quot;); logger.info(&quot;----------初始化配置信息结束---------------&quot;); } /** * 供外部调用达到限流降级作用 * @param toRun * @param fallback 异常回滚方法 * @param &lt;T&gt; * @return */ public &lt;T&gt; T run(Supplier&lt;T&gt; toRun, Function&lt;Throwable, T&gt; fallback) { try { if (state == HystrixStatus.OPEN) { // 判断 是否超时可以进入 half-open状态 if (halfOpenTimeout()) { return halfOpenHandle(toRun, fallback); } // 直接执行失败回调方法 return fallback.apply(new Exception( hystrixName + &quot; is running&quot;)); // 如果降级关闭则正常执行 } else if (state == HystrixStatus.CLOSED) { CompletableFuture&lt;T&gt; asyncCall = CompletableFuture.supplyAsync(toRun); T result = asyncCall.get(HYSTRIX_TIME_OUT, TimeUnit.SECONDS);//2S 业务自己断开// asyncCall.exceptionally(fallback); // 注意重置 错误数 closed(); return result; } else { // if (state == half-Open) return halfOpenHandle(toRun, fallback); } } catch (Exception e) { logger.info(hystrixName + &quot;:&quot; + e.getMessage()); // 执行失败 错误次数+ 1 counter.incrFailureCount(); // 错误次数达到阀值，进入 open 状态 if (counter.failureThresholdReached()) { logger.info(hystrixName + &quot;: 开启断路器 ！！！&quot;); open(); } return fallback.apply(e); } } /** * 转换为 half-Open状态 * @param toRun * @param fallback * @param &lt;T&gt; * @return */ private &lt;T&gt; T halfOpenHandle(Supplier&lt;T&gt; toRun, Function&lt;Throwable, T&gt; fallback) { try { // closed 状态超时进入 half-open 状态 halfOpen(); CompletableFuture&lt;T&gt; asyncCall = CompletableFuture.supplyAsync(toRun); T result = asyncCall.get(HYSTRIX_TIME_OUT, TimeUnit.SECONDS);//2S 业务自己断开 int halfOpenSuccCount = counter.incrSuccessHalfOpenCount(); // half-open 状态成功次数到达阀值，进入 closed 状态 if (halfOpenSuccCount &gt;= this.config.getHalfOpenSuccessCount()) { closed(); } return result; } catch (Exception e) { // half-open 状态发生一次错误进入 open 状态 open(); // degrade by circuit breaker return fallback.apply(new Exception(e.getMessage())); } } /** * 判断是否 Open是否超时， 如果是则进入 halfOpen状态 * @return */ public boolean halfOpenTimeout() { return System.currentTimeMillis() - lastOpenedTime &gt; config.getHalfOpenTimeout(); } public void closed() { counter.reset(); state = HystrixStatus.CLOSED; } public void open() { state = HystrixStatus.OPEN; lastOpenedTime = System.currentTimeMillis(); } public void halfOpen() { state = HystrixStatus.HALF_OPEN; }} 计数器类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package cn.com.winning.bd.api.hystrix;import java.util.Date;import java.util.concurrent.atomic.AtomicInteger;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * * ClassName: HystrixCounter * @Description: 计数器 * @date 2022年4月15日 */public class HystrixCounter { // Closed 状态进入 Open 状态的错误个数阀值 private final int failureCount; // failureCount 统计时间窗口 private final long failureTimeInterval; // 当前错误次数 private final AtomicInteger currentCount; // 上一次调用失败的时间戳 private long lastTime; // Half-Open 状态下成功次数 private final AtomicInteger halfOpenSuccessCount; private static final Logger logger = LoggerFactory.getLogger(HystrixCounter.class); public HystrixCounter(int failureCount, long failureTimeInterval) { this.failureCount = failureCount; this.failureTimeInterval = failureTimeInterval; this.currentCount = new AtomicInteger(0); this.halfOpenSuccessCount = new AtomicInteger(0); this.lastTime = System.currentTimeMillis(); logger.info(&quot;----------初始化配置信息开始---------------&quot;); logger.info(&quot;统计时间窗口时间：&quot; + this.failureTimeInterval + &quot;ms&quot;); logger.info(&quot;错误状态个数阀值：&quot; + this.failureCount); logger.info(&quot;上一次错误时间：&quot; + new Date(this.lastTime));// logger.info(&quot;----------初始化配置信息结束---------------&quot;); } /** * 失败次数 + 1 * synchronized 保证线程安全 * @return */ public synchronized int incrFailureCount() { long current = System.currentTimeMillis(); // 超过时间窗口，当前失败次数重置为 0 if (current - lastTime &gt; failureTimeInterval) { lastTime = current; currentCount.set(0); } return currentCount.getAndIncrement(); } /** * half Open 状态下 成功数 + 1 * @return */ public int incrSuccessHalfOpenCount() { return this.halfOpenSuccessCount.incrementAndGet(); } /** * 失败总次数是否超过阈值 * @return */ public boolean failureThresholdReached() { return getCurCount() &gt;= failureCount; } public int getCurCount() { return currentCount.get(); } /** * 重置 */ public synchronized void reset() { halfOpenSuccessCount.set(0); currentCount.set(0); }} 配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.com.winning.bd.api.hystrix;public class HystrixConfig { /** * Closed 状态进入 Open 状态的错误个数阀值 */ private int failureCount = 2; /** * failureCount 统计时间窗口（超过该时间重置失败次数） * 10分钟内不重置失败次数 */ private long failureTimeInterval = 10 * 60 * 1000; /** * Open 状态进入 Half-Open 状态的超时时间 * 1分钟重试一次 */ private int halfOpenTimeout = 2 * 60 * 1000; /** * Half-Open 状态进入 Open 状态的成功个数阀值 */ private int halfOpenSuccessCount = 2; public int getFailureCount() { return failureCount; } public void setFailureCount(int failureCount) { this.failureCount = failureCount; } public long getFailureTimeInterval() { return failureTimeInterval; } public void setFailureTimeInterval(long failureTimeInterval) { this.failureTimeInterval = failureTimeInterval; } public int getHalfOpenTimeout() { return halfOpenTimeout; } public void setHalfOpenTimeout(int halfOpenTimeout) { this.halfOpenTimeout = halfOpenTimeout; } public int getHalfOpenSuccessCount() { return halfOpenSuccessCount; } public void setHalfOpenSuccessCount(int halfOpenSuccessCount) { this.halfOpenSuccessCount = halfOpenSuccessCount; }}","link":"/2022/04/24/%E7%AE%80%E5%8D%95%E6%96%AD%E8%B7%AF%E5%99%A8%E5%AE%9E%E7%8E%B0/"},{"title":"链表","text":"链表链表的节点定义1234567891011121314151617public class ListNode { int value; ListNode next; public ListNode() { } public ListNode(int value) { this.value = value; next = null; } public ListNode(int value, ListNode next) { this.value = value; this.next = next; }} 链表的定义：添加元素,反转方法,打印12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class LinkList { ListNode head; // 尾插法 public void endAdd(int n) { ListNode listnode = new ListNode(n); if(head==null) { head=listnode; return; } ListNode temp = head; while(temp.next!=null) { temp=temp.next; } temp.next=listnode; } // 头插法 public void startAdd(int n) { ListNode listnode = new ListNode(n); listnode.next = head; head = listnode; } //把添加的值打印的方法 public void printLink() { ListNode temp=head; while(temp!=null) { System.out.print(temp.value+&quot; &quot;); temp=temp.next; } System.out.println(); } public void reverse(){ //定义一个带头节点的 ListNode resultList = new ListNode(-1); //循环节点 ListNode p = head; while(p!= null){ //保存插入点之后的数据 ListNode tempList = p.next; p.next = resultList.next; resultList.next = p; p = tempList; } head = resultList.next; }} 反转原理：遍历原有链表，通过一个临时 节点，交换原始链表的第一个节点，赋值给 新的链表尾部 测试结果123456789101112131415 public static void main(String[] args) { LinkList linkList = new LinkList(); linkList.startAdd(1); linkList.startAdd(2); linkList.startAdd(3); linkList.startAdd(4); linkList.startAdd(5); linkList.startAdd(6); linkList.printLink(); linkList.reverse(); linkList.printLink(); }# 控制台输出6 5 4 3 2 1 1 2 3 4 5 6","link":"/2022/04/25/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"写给自己","text":"hello world !!!!","link":"/2022/04/12/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1/"},{"title":"icarus","text":"_config.icarus.yml 相关配置中文详解 美化：https://www.alphalxy.com/2019/03/customize-icarus/#%E6%96%87%E7%AB%A0%E9%A1%B5%E9%9D%A2%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418# 模板版本version: 4.0.0# Icarus 主题样式，一种默认，一种赛博朋克&quot;default&quot; or &quot;cyberpunk&quot;variant: default# 顶部logo 设置你站点的logo。 此logo会显示在导航栏和页脚。 图片或者是文字logo: https://gitee.com/cnhuashao/picgo-images/raw/master/20210902174326.png# 页面元数据配置head: # 浏览器图标 favicon: https://gitee.com/cnhuashao/picgo-images/raw/master/20210831154758.png # Web应用程序清单配置 Icarus支持基本的PWAmanifest.json的生成与Meta标签 # https://developer.mozilla.org/en-US/docs/Web/Manifest manifest: # web应用程序的名称(默认为站点标题) name: CN華少 # 显示的web应用程序名称 # 当没有足够的空间显示全名时 short_name: CN華少 # web应用程序的起始URL start_url: https://blog.cnhuashao.com # 应用程序的默认主题颜色 theme_color: # 在加载样式表之前，要显示的应用程序页面的占位符背景颜色 background_color: # 网站的首选显示模式 display: standalone # 可以作为不同上下文的应用程序图标的图像文件 icons: - # 映像文件的路径 src: '' # 包含空格分隔的图像维数的字符串 sizes: '' # 关于图像的媒体类型的提示 type: # 打开图元数据 # https://hexo.io/docs/helpers.html#open-graph open_graph: # 页面标题(og:title)(可选) # 你应该在大部分时间里把这个空着 title: CN華少 # 页面类型(og:type)(可选) # 你应该在大部分时间里把这个空着 type: blog # 页面URL (og: URL)(可选) # 你应该在大部分时间里把这个空着 url: https://blog.cnhuashao.com/ # 封面地址 (og:image) (可选) # 你应该在大部分时间里把这个空着 image: https://gitee.com/cnhuashao/picgo-images/raw/master/psc.jpg # 站点名 (og:site_name) (可选) # 你应该在大部分时间里把这个空着 site_name: CN華少 # 创建作者 (article:author) (可选) # 你应该在大部分时间里把这个空着 author: CN華少 # 页面描述 (og:description) (可选) # 你应该在大部分时间里把这个空着 description: # Twitter card type (twitter:card) twitter_card: # Twitter ID (twitter:creator) twitter_id: # Twitter Site (twitter:site) twitter_site: # Google+ profile link (deprecated) google_plus: # Facebook admin ID fb_admins: # Facebook App ID fb_app_id: # 页面的结构化数据 # https://developers.google.com/search/docs/guides/intro-structured-data structured_data: # 页标题 (可选) # 你应该在大部分时间里把这个空着 title: # 页面描述 (可选) # 你应该在大部分时间里把这个空着 description: # 链接页面网址 (可选) # 你应该在大部分时间里把这个空着 url: # 创建作者 (article:author) (可选) # 你应该在大部分时间里把这个空着 author: # 页面的出版商 (可选) # 你应该在大部分时间里把这个空着 publisher: # 页面出版商标志 (可选) # 你应该在大部分时间里把这个空着 publisher_logo: # 页面图片 (可选) # 你应该在大部分时间里把这个空着 image: # 数组中的附加HTML元标记 meta: # Meta tag specified in &lt;attribute&gt;=&lt;value&gt; style # E.g., name=theme-color;content=#123456 =&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#123456&quot;&gt; - '' # 网址或路径到网站的RSS atom.xml rss: atom.xml# 页面顶部导航栏配置navbar: # 导航菜单项 menu: 首页: / 文章归档: /archives 分类: /categories 标签: /tags 个人简介: /about 留言: /message 音乐: /music 媒体: /media # 导航右侧快捷方式 links: Gitee: icon: fab fa-git-square url: 'https://gitee.com/cnhuashao'# 页脚footer: # 右侧超链接设置 links: 知识共享: icon: fab fa-creative-commons url: 'https://creativecommons.org/' CC BY-NC 4.0: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by-nc/4.0/deed.zh' Download on Gitee: icon: fab fa-git-square url: 'https://gitee.com/cnhuashao'# 文章相关配置article: # 代码高亮显示设置 highlight: # 代码高亮显示主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制代码按钮 clipboard: true # 代码块的默认折叠状态。 可以是 &quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 显示文章字数统计以及预计阅读时间。 readtime: true # 文章许可协议 licenses: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by-nc/4.0/' Noncommercial: icon: fab fa-creative-commons-nc url: 'https://creativecommons.org/licenses/by-nc/4.0/'# 搜索插件配置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Search/search: type: insight# 评论插件配置-这里使用的畅言# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Comment/comment: type: changyan # Disqus shortname app_id: conf: # 捐赠插件配置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Donation/donates: # &quot;Afdian.net&quot; 捐赠按钮配置 #- # type: afdian # URL to the &quot;Afdian.net&quot; personal page # url: '' # 支付宝捐赠按钮配置 - type: alipay # Alipay qrcode image URL qrcode: 'https://gitee.com/cnhuashao/picgo-images/raw/master/20210902142707.jpg' # &quot;Buy me a coffee&quot; donate button configurations #- # type: buymeacoffee # URL to the &quot;Buy me a coffee&quot; page # url: '' # Patreon donate button configurations #- # type: patreon # URL to the Patreon page # url: '' # Paypal donate button configurations #- # type: paypal # Paypal business ID or email address # business: '' # Currency code # currency_code: USD # 微信捐赠按钮配置 - type: wechat # Wechat qrcode image URL qrcode: 'https://gitee.com/cnhuashao/picgo-images/raw/master/20210902142706.jpg'# 分享插件配置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Share/share: type: sharethis # URL to the ShareThis share plugin script install_url: ''# 侧边栏的配置。# 请注意，侧边栏只有在至少有一个小部件时才可见sidebar: # 左栏的配置 left: # 当页面滚动时左侧侧边栏是否停留在顶部 sticky: true # Right sidebar configurations right: # Whether the sidebar sticks to the top when page scrolls sticky: true# 布局配置文件遵循着与主题配置文件相同的格式和定义。# _config.post.yml中的配置对所有文章生效，而_config.page.yml中的配置对所有自定义页面生效。# 这两个文件将覆盖主题配置文件中的配置。# 注： 如果想对于文章进行单独设置时，我们就启用_config.post.yml配置文件配置# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: # 个人信息小部件配置 - # 小部件应该放在哪里，左边栏还是右边栏 position: left type: profile # 作者名称 author: CN華少 # 作者标题 author_title: 想做、能做、去做、做到、做好 # 当前位置 location: 中国，山东，济南 # 图像URL avatar: https://gitee.com/cnhuashao/picgo-images/raw/master/psc.jpg # 是否显示圆形头像图像 avatar_rounded: true # Gravatar头像邮箱地址 gravatar: # 关注按钮的URL或路径 follow_link: 'https://github.com/cnHuaShao' # 底部快捷连接配置 social_links: Gitee: icon: fab fa-git-square url: 'https://gitee.com/cnHuaShao' Email: icon: fa fa-envelope url: 'mailto:lz2392504@gmail.com' Weibo: icon: fab fa-weibo url: '' WeiXin: icon: fab fa-weixin url: '' Next: icon: fab fa-dribbble url: 'https://blog.cnhuashao.com/remove.io' RSS: icon: fas fa-rss url: / # 目录 小部件配置 - # 小部件显示位置 position: right type: toc # 是否显示每个标题的索引 index: true # 是否在看不到副标题时折叠副标题 collapsed: true # 标题显示的最高水平 depth: 3 # 链接小部件配置 - # 左边栏还是右边栏 position: left type: links # 站点的名称和url links: Hexo: 'https://hexo.io' Gitee: 'https://gitee.com/cnhuashao' # 分类小部件配置 - # Where should the widget be placed, left sidebar or right sidebar position: right type: categories # 最新文章小部件配置 - # Where should the widget be placed, left sidebar or right sidebar position: left type: recent_posts # 档案小部件的配置 - # Where should the widget be placed, left sidebar or right sidebar position: left type: archives # 标签小部件的配置 - # Where should the widget be placed, left sidebar or right sidebar position: right type: tags # 邮件订阅widget配置 - # Where should the widget be placed, left sidebar or right sidebar position: left type: subscribe_email # Hint text under the email input description: # Feedburner ID feedburner_id: '' # 谷歌AdSense单元配置 - # Where should the widget be placed, left sidebar or right sidebar position: right type: adsense # data-ad-client client_id: '' # data-ad-slot slot_id: '' # Follow.跟进。它的电子邮件订阅小部件配置 - # Where should the widget be placed, left sidebar or right sidebar position: left type: followit # Hint text under the email input description: # Subscription form action URL action_url: '' # Feed claiming verification code verification_code: ''# 插件配置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/plugins: # 启用页面启动动画 animejs: true # 显示“返回顶部”按钮 back_to_top: true # 百度分析插件设置 # https://tongji.baidu.com baidu_analytics: # Baidu Analytics tracking ID tracking_id: # Bing网站管理员工具插件设置 # https://www.bing.com/toolbox/webmaster/ bing_webmaster: # Bing Webmaster Tools tracking ID in the &lt;meta&gt; tag tracking_id: # 不蒜子网页计数器 # https://busuanzi.ibruce.info busuanzi: false # CNZZ统计 # https://www.umeng.com/web cnzz: # CNZZ tracker id id: # CNZZ website id web_id: # 提醒用户cookies的使用 # https://www.osano.com/cookieconsent/ cookie_consent: # The compliance type. Can be &quot;info&quot;, &quot;opt-in&quot;, or &quot;opt-out&quot; type: info # Theme of the popup. Can be &quot;block&quot;, &quot;edgeless&quot;, or &quot;classic&quot; theme: edgeless # Whether the popup should stay static regardless of the page scrolls static: false # Where on the screen the consent popup should display position: bottom-left # URL to your site's cookie policy policyLink: 'https://www.cookiesandyou.com/' # Enable the lightGallery and Justified Gallery plugins gallery: true # 谷歌分析插件设置 # https://analytics.google.com google_analytics: # Google Analytics tracking ID tracking_id: # Hotjar user feedback plugin # https://www.hotjar.com/ hotjar: # Hotjar site id site_id: # Enable the KaTeX math typesetting support # https://katex.org/ katex: false # Enable the MathJax math typesetting support # https://www.mathjax.org/ mathjax: false # 浏览器升级提醒 # http://outdatedbrowser.com/ outdated_browser: false # 网页载入进度条 progressbar: true # Statcounter statistics # https://statcounter.com/ statcounter: # Statcounter project id project: # Statcounter project security code security: # Twitter conversion tracking plugin settings # https://business.twitter.com/en/help/campaign-measurement-and-analytics/conversion-tracking-for-websites.html twitter_conversion_tracking: # Twitter Pixel ID pixel_id: # CDN 提供商# https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/speed-up-your-site-with-custom-cdn/providers: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: jsdelivr # Name or URL template of the webfont CDN provider fontcdn: google # Name or URL of the fontawesome icon font CDN provider iconcdn: fontawesome","link":"/2022/04/19/icarus%E9%85%8D%E7%BD%AE/"},{"title":"OkHttp3","text":"添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt; 引入json是因为工具类中有些地方用到了，现在通信都流行使用json传输，也少不了要这个jar包 工具类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293import com.alibaba.fastjson.JSON;import okhttp3.*; import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSocketFactory;import javax.net.ssl.TrustManager;import javax.net.ssl.X509TrustManager;import java.io.IOException;import java.net.URLEncoder;import java.security.SecureRandom;import java.security.cert.X509Certificate;import java.util.LinkedHashMap;import java.util.Map;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit; public class OkHttpUtils { private static volatile OkHttpClient okHttpClient = null; private static volatile Semaphore semaphore = null; private Map&lt;String, String&gt; headerMap; private Map&lt;String, String&gt; paramMap; private String url; private Request.Builder request; /** * 初始化okHttpClient，并且允许https访问 */ private OkHttpUtils() { if (okHttpClient == null) { synchronized (OkHttpUtils.class) { if (okHttpClient == null) { TrustManager[] trustManagers = buildTrustManagers(); okHttpClient = new OkHttpClient.Builder() .connectTimeout(15, TimeUnit.SECONDS) .writeTimeout(20, TimeUnit.SECONDS) .readTimeout(20, TimeUnit.SECONDS) .sslSocketFactory(createSSLSocketFactory(trustManagers), (X509TrustManager) trustManagers[0]) .hostnameVerifier((hostName, session) -&gt; true) .retryOnConnectionFailure(true) .build(); addHeader(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;); } } } } /** * 用于异步请求时，控制访问线程数，返回结果 * * @return */ private static Semaphore getSemaphoreInstance() { //只能1个线程同时访问 synchronized (OkHttpUtils.class) { if (semaphore == null) { semaphore = new Semaphore(0); } } return semaphore; } /** * 创建OkHttpUtils * * @return */ public static OkHttpUtils builder() { return new OkHttpUtils(); } /** * 添加url * * @param url * @return */ public OkHttpUtils url(String url) { this.url = url; return this; } /** * 添加参数 * * @param key 参数名 * @param value 参数值 * @return */ public OkHttpUtils addParam(String key, String value) { if (paramMap == null) { paramMap = new LinkedHashMap&lt;&gt;(16); } paramMap.put(key, value); return this; } /** * 添加请求头 * * @param key 参数名 * @param value 参数值 * @return */ public OkHttpUtils addHeader(String key, String value) { if (headerMap == null) { headerMap = new LinkedHashMap&lt;&gt;(16); } headerMap.put(key, value); return this; } /** * 初始化get方法 * * @return */ public OkHttpUtils get() { request = new Request.Builder().get(); StringBuilder urlBuilder = new StringBuilder(url); if (paramMap != null) { urlBuilder.append(&quot;?&quot;); try { for (Map.Entry&lt;String, String&gt; entry : paramMap.entrySet()) { urlBuilder.append(URLEncoder.encode(entry.getKey(), &quot;utf-8&quot;)). append(&quot;=&quot;). append(URLEncoder.encode(entry.getValue(), &quot;utf-8&quot;)). append(&quot;&amp;&quot;); } } catch (Exception e) { e.printStackTrace(); } urlBuilder.deleteCharAt(urlBuilder.length() - 1); } request.url(urlBuilder.toString()); return this; } /** * 初始化post方法 * * @param isJsonPost true等于json的方式提交数据，类似postman里post方法的raw * false等于普通的表单提交 * @return */ public OkHttpUtils post(boolean isJsonPost) { RequestBody requestBody; if (isJsonPost) { String json = &quot;&quot;; if (paramMap != null) { json = JSON.toJSONString(paramMap); } requestBody = RequestBody.create(MediaType.parse(&quot;application/json; charset=utf-8&quot;), json); } else { FormBody.Builder formBody = new FormBody.Builder(); if (paramMap != null) { paramMap.forEach(formBody::add); } requestBody = formBody.build(); } request = new Request.Builder().post(requestBody).url(url); return this; } /** * 同步请求 * * @return */ public String sync() { setHeader(request); try { Response response = okHttpClient.newCall(request.build()).execute(); assert response.body() != null; return response.body().string(); } catch (IOException e) { e.printStackTrace(); return &quot;请求失败：&quot; + e.getMessage(); } } /** * 异步请求，有返回值 */ public String async() { StringBuilder buffer = new StringBuilder(&quot;&quot;); setHeader(request); okHttpClient.newCall(request.build()).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { buffer.append(&quot;请求出错：&quot;).append(e.getMessage()); } @Override public void onResponse(Call call, Response response) throws IOException { assert response.body() != null; buffer.append(response.body().string()); getSemaphoreInstance().release(); } }); try { getSemaphoreInstance().acquire(); } catch (InterruptedException e) { e.printStackTrace(); } return buffer.toString(); } /** * 异步请求，带有接口回调 * * @param callBack */ public void async(ICallBack callBack) { setHeader(request); okHttpClient.newCall(request.build()).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { callBack.onFailure(call, e.getMessage()); } @Override public void onResponse(Call call, Response response) throws IOException { assert response.body() != null; callBack.onSuccessful(call, response.body().string()); } }); } /** * 为request添加请求头 * * @param request */ private void setHeader(Request.Builder request) { if (headerMap != null) { try { for (Map.Entry&lt;String, String&gt; entry : headerMap.entrySet()) { request.addHeader(entry.getKey(), entry.getValue()); } } catch (Exception e) { e.printStackTrace(); } } } /** * 生成安全套接字工厂，用于https请求的证书跳过 * * @return */ private static SSLSocketFactory createSSLSocketFactory(TrustManager[] trustAllCerts) { SSLSocketFactory ssfFactory = null; try { SSLContext sc = SSLContext.getInstance(&quot;SSL&quot;); sc.init(null, trustAllCerts, new SecureRandom()); ssfFactory = sc.getSocketFactory(); } catch (Exception e) { e.printStackTrace(); } return ssfFactory; } private static TrustManager[] buildTrustManagers() { return new TrustManager[]{ new X509TrustManager() { @Override public void checkClientTrusted(X509Certificate[] chain, String authType) { } @Override public void checkServerTrusted(X509Certificate[] chain, String authType) { } @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[]{}; } } }; } /** * 自定义一个接口回调 */ public interface ICallBack { void onSuccessful(Call call, String data); void onFailure(Call call, String errorMsg); }} 调用示例 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) { // get请求，方法顺序按照这种方式，切记选择post/get一定要放在倒数第二，同步或者异步倒数第一，才会正确执行 OkHttpUtils.builder().url(&quot;请求地址，http/https都可以&quot;) // 有参数的话添加参数，可多个 .addParam(&quot;参数名&quot;, &quot;参数值&quot;) .addParam(&quot;参数名&quot;, &quot;参数值&quot;) // 也可以添加多个 .addHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;) .get() // 可选择是同步请求还是异步请求 //.async(); .sync(); // post请求，分为两种，一种是普通表单提交，一种是json提交 OkHttpUtils.builder().url(&quot;请求地址，http/https都可以&quot;) // 有参数的话添加参数，可多个 .addParam(&quot;参数名&quot;, &quot;参数值&quot;) .addParam(&quot;参数名&quot;, &quot;参数值&quot;) // 也可以添加多个 .addHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;) // 如果是true的话，会类似于postman中post提交方式的raw，用json的方式提交，不是表单 // 如果是false的话传统的表单提交 .post(true) .sync(); // 选择异步有两个方法，一个是带回调接口，一个是直接返回结果 OkHttpUtils.builder().url(&quot;&quot;) .post(false) .async(); OkHttpUtils.builder().url(&quot;&quot;).post(false).async(new OkHttpUtils.ICallBack() { @Override public void onSuccessful(Call call, String data) { // 请求成功后的处理 } @Override public void onFailure(Call call, String errorMsg) { // 请求失败后的处理 } });}","link":"/2022/04/20/okHttp3%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"String","text":"StringStringBuffer，StringBuilder区别是什么？标准答案：前者线程安全，后者线程不安全。 Java 语言设计之初，就是为了替代（当时）极其复杂原始的C/C++，其中的一个大改进就是，把并发（多线程）的理念贯彻到了语言的各个角落。 例如，当初 Java 设计者将 Java 语言设计成所有对象都支持作为 synchronized 代码块的互斥锁使用，还把 wait、notify 等 final 方法放到万物之源 Object 类。为什么最初几乎所有可变对象如 StringBuffer、Vector、Hashtable、ByteArray{Input,Output}Stream 等都要设计成线程安全的？ 因为当初的语言设计者认为多线程是万金油，这些可变对象几乎都会被多个线程同时修改，所以为了避免 Race Condition，也为了避免程序员频繁使用 synchronized 代码块造成可读性和易用性降低，就把它们统统设计成“线程安全”的，让保持同步的脏活累活都留给标准库干，反正也不影响单线程下的准确性，无非损失亿点性能而已。但事实证明，多个线程同时修改一个对象的场景才是少数，绝大多数可变对象只会被一个线程修改，然而因为频繁不必要的上锁、释放锁的操作，使得性能损失很大，所以你会看到，后来的 ArrayList、HashMap 等可变类都不再默认线程安全，以此换取单线程下的性能提升，然后用 Collections.synchronizedXxx 等方法提供少数情况需要多线程安全的可变对象。 这个问题的主角 StringBuffer 和 StringBuilder 也是一样的，后者就是为纠正历史遗留问题，提高单线程下的性能而生的，而为了向下兼容性和需要线程安全的场景，才保留 StringBuffer 类。 随着内存越来越大，函数式编程的“万物皆 immutable”的思想流行，Java 也出现越来越多的不可变类，例如 java.time 包中的类、Optional 类、 List.of、Set.of 返回的不可变集合等。这才是多进程、多线程下保证准确性、提升性能的新的解决方案。 四个线程安全策略 线程限制1一个被线程限制的对象，由线程独占，只能被线程占有的线程修改 共享只读1在没有额外同步的情况下，可以被多个线程并发访问，不能修改 线程安全对象1一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，所以其他线程无需额外的同步就可以通过公共接口随意访问它 被守护对象1被守护对象只能通过获取特定的锁来访问 不可变对象在Java中，有一种对象发布了就是安全的，被称之为不可变对象。 不可变对象可以在多线程中可以保证线程安全 不可变对象满足的条件 对象创建之后状态就不能修改 对象的域都是 final 类型 对象是正确创建的（对象在创建期间，this引用没有溢出，外部不可见） 创建不可变对象 将类声明成final类型，使其不可以被继承 将所有的成员设置成私有的，使其他的类和对象不能直接访问这些成员 对变量不提供set方法 将所有可变的成员声明为final，这样只能对他们赋值一次 通过构造器初始化所有成员，进行深度拷贝 在get方法中，不直接返回对象本身，而是克隆对象，返回对象的拷贝 JDK中的 Collections.unmodifiableXXX传入的对象一经初始化便无法修改,XXX可表示Collection、List、Set、Map等 Collections.UnmodifiableMap的源码 主要是将一个新的集合所有更新方法变成抛出异常","link":"/2022/04/18/String/"},{"title":"线程池","text":"一、线程1.1 什么是线程线程是进程中得一个实体，线程本身是不会独立存在的。进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程中至少有一线程，进程中的多个线程共享进程的资源。 1.1 为什么需要线程池线程池是一种基于池化思想管理线程的工具，类似于数据库连接池。 基于池化的思想是提前创建一定数量的 Connection 对象，然后将其存放起来，这样每次需要的时候直接从池中获取 Connection 对象即可，避免了频繁的创建和销毁的操作。线程池则是将线程 Thread 对象提前创建缓存起来，这样当提交任务的时候直接将任务提交给池中的线程即可，而不需要创建新的 Thread。总结线程池的优势： 传统创建线程的方式对资源无限申请缺少抑制手段，容易引发资源耗尽的风险 通过复用线程池中的线程可以避免频繁创建线程，省去创建线程的时间，提高响应速度 线程池可以指定最大线程数量，超出的任务会在等待队列等待，不会出现大量线程耗尽服务器资源 提升系统响应速度,假如创建线程用的时间为T1，执行任务用的时间为T2,销毁线程用的时间为T3，那么使用线程池就免去了T1和T3的时间 二、线程池介绍2.1 ThreadPoolExecutor类继承结构如下 顶层接口 Executor 提供了一种思想：将任务提交和任务执行进行解耦。 只需要把要做的事情交给线程池就行了。 2.1.1 ThreadPoolExecutor 参数介绍1234567891011public ThreadPoolExecutor( int corePoolSize, //核心线程数量 int maximumPoolSize,// 最大线程数 long keepAliveTime, // 最大空闲时间 TimeUnit unit, // 时间单位 BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列 ThreadFactory threadFactory, // 线程工厂 RejectedExecutionHandler handler // 饱和处理机制,拒绝策略 ) { ... } 2.1.2 场景代入理解 a客户(任务)去银行(线程池)办理业务,但银行刚开始营业,窗口服务员还未就位(相当于线程池中初始线程数量为0),于是经理(线程池管理者)就安排1号工作人员(创建1号线程执行任务)接待a客户(创建线程); 在a客户业务还没办完时,b客户(任务)又来了,于是经理(线程池管理者)就安排2号工作人员(创建2号线程执行任务)接待b客户(又创建了一个新的线程);假设该银行总共就2个窗口(核心线程数量是2); 紧接着在a,b客户都没有结束的情况下c客户来了,于是经理(线程池管理者)就安排c客户先坐到银行大厅的座位上(空位相当于是任务队列)等候,并告知他: 如果1、2号工作人员空出,c就可以前去办理业务; 此时d客户又到了银行,(工作人员都在忙,大厅座位也满了)于是经理赶紧安排临时工(新创建的线程)在大堂站着,手持pad设备给d客户办理业务; 假如前面的业务都没有结束的时候e客户又来了,此时正式工作人员都上了,临时工也上了,座位也满了(临时工加正式员工的总数量就是最大线程数),于是经理只能按《超出银行最大接待能力处理办法》(饱和处理机制)拒接接待e客户; 最后,进来办业务的人少了,大厅的临时工空闲时间也超过了1个小时(最大空闲时间),经理就会让这部分空闲的员工人下班.(销毁线程)但是为了保证银行银行正常工作(有一个allowCoreThreadTimeout变量控制是否允许销毁核心线程,默认false),即使正式工闲着,也不得提前下班,所以1、2号工作人员继续待着(池内保持核心线程数量); 2.1.3 线程池的工作流程 1.核心线程数(corePoolSize) 线程池中正在运行的线程数量小于 corePoolSize 时，新任务来了会创建新线程执行任务 核心线程数的设计需要依据任务的处理时间和每秒产生的任务数量来确定,例如:执行一个任务需要0.1秒,系统百分之80的时间每秒都会产生100个任务,那么要想在1秒内处理完这100个任务,就需要10个线程,此时我们就可以设计核心线程数为10; 当然实际情况不可能这么平均,所以我们一般按照80/20原则设计即可,既按照百分之80的情况设计核心线程数,剩下的百分之20可以利用最大线程数处理; 2.任务队列长度(workQueue) 用于保存等执行的任务的阻塞队列，比如基于数组的有界队列ArrayBlockingQueue、基于链表的无界LinkedBlockingQueue、和最多只有一个元素的同步队列SynchronousQueue等 任务队列长度一般设计为:核心线程数/单个任务执行时间*2即可;例如上面的场景中,核心线程数设计为10,单个任务执行时间为0.1秒,则队列长度可以设计为200; 3.最大线程数(maximumPoolSize) 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize； 最大线程数的设计除了需要参照核心线程数的条件外,还需要参照系统每秒产生的最大任务数决定:例如:上述环境中,如果系统每秒最大产生的任务是1000个,那么,最大线程数=(最大任务数-任务队列长度)单个任务执行时间;既: 最大线程数=(1000-200)0.1=80个; 4.最大空闲时间(keepAliveTime) 线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用； 这个参数的设计完全参考系统运行环境和硬件压力设定,没有固定的参考值,用户可以根据经验和系统产生任务的时间间隔合理设置一个值即可; 5. 拒绝策略(RejectedExecutionHandler) 当线程池中的工作线程数已经达到了 maximumPoolSize，此时再提交任务就会被拒绝，JDK 提供了四种拒绝策略 AbortPolicy 丢弃任务并抛出RejectedExecutionException 异常。这是线程池默认策略，如果是比较关键的业务推荐使用此策略，这样在子系统不能承载更大并发的时候，能够及时通过异常发现 DiscardPolicy 丢弃任务但是不抛出异常。使用此策略可能会使我们无法发现系统的异常，一般无关紧要的业务使用此策略 DiscardOldestPolicy 丢弃队列最前面的任务， 也就是最早的任务，然后重新提交被拒绝的任务 CallerRunsPolicy 由调用线程（提交任务的线程）处理该任务。相当于是把任务交给主线程去执行，这样由于主线程在执行任务就会被阻塞，就不会继续给线程池提交任务，在某些情况下来说这也是个不错的拒绝策略。 当然我们也可以实现自己的拒绝策略，只需要实现 RejectedExecutionHandler 重写拒绝逻辑即可。 第三方实现的拒绝策略：Dubbo、Netty、ActiveMQ、PinPoint等均有各自实现的拒绝策略 2.1.4 线程池的状态 RUNNING ：运行状态。能接受新提交的任务，并且也能处理阻塞队列中的任务 SHUTDOWN ： 关闭状态。不再接受新提交的任务，能处理阻塞队列中的已经保存的任务 STOP ： 停止状态。不能接受新提交的任务，也不能处理阻塞队列中的任务，会中断正在处理任务的线程 TIDYING ： 所有任务都终止了，workerCount （工作线程数）为 0 TERMINATED ： 终止状态。terminated() 方法执行完进入该状态。 拒绝策略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package cn.com.winning.bg.test.thread;import java.util.concurrent.RejectedExecutionException;import java.util.concurrent.RejectedExecutionHandler;import java.util.concurrent.ThreadPoolExecutor;public class ThreadRejectedExecutionHandler implements RejectedExecutionHandler{ @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {} /** * 饱和策略一：调用者线程执行策略 * 在该策略下，在调用者中执行被拒绝任务的run方法。除非线程池showdown，否则直接丢弃线程 */ public static class CallerRunsPolicy extends ThreadRejectedExecutionHandler { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { //判断线程池是否在正常运行，如果线程池在正常运行则由调用者线程执行被拒绝的任务。如果线程池停止运行，则直接丢弃该任务 if (!executor.isShutdown()){ r.run(); } } } /** * 饱和策略二：终止策略 * 在该策略下，丢弃被拒绝的任务，并抛出拒绝执行异常 */ public static class AbortPolicy extends ThreadRejectedExecutionHandler { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { throw new RejectedExecutionException(&quot;请求任务：&quot; + r.toString() + &quot;，线程池负载过高执行饱和终止策略！&quot;); } } /** * 饱和策略三：丢弃策略 * 在该策略下，什么都不做直接丢弃被拒绝的任务 */ public static class DiscardPolicy extends ThreadRejectedExecutionHandler { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {} } /** * 饱和策略四：弃老策略 * 在该策略下，丢弃最早放入阻塞队列中的线程，并尝试将拒绝任务加入阻塞队列 */ public static class DiscardOldestPolicy extends ThreadRejectedExecutionHandler { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { //判断线程池是否正常运行，如果线程池正常运行则弹出（或丢弃）最早放入阻塞队列中的任务，并尝试将拒绝任务加入阻塞队列。如果线程池停止运行，则直接丢弃该任务 if (!executor.isShutdown()){ executor.getQueue().poll(); executor.execute(r); } } }} 线程创建工厂类 1234567891011121314package cn.com.winning.bg.test.thread;import java.util.concurrent.ThreadFactory;public class MyThreadFactory implements ThreadFactory{ @Override public Thread newThread(Runnable r) { Thread newThread = new Thread(r); return newThread; }} 线程池工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package cn.com.winning.bg.test.thread;import java.util.List;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * 线程池工具类 * ClassName: ThreadPoolUtils * @Description: TODO * @date 2022年4月19日 */public class ThreadPoolUtils { /** * 系统可用计算资源 */ private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); /** * 核心线程数 */ private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4)); /** * 最大线程数 */ private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; /** * 空闲线程存活时间 */ private static final int KEEP_ALIVE_SECONDS = 30; /** * 工作队列 */ private static final BlockingQueue&lt;Runnable&gt; POOL_WORK_QUEUE = new LinkedBlockingQueue&lt;&gt;(128); /** * 工厂模式 */ private static final MyThreadFactory MY_THREAD_FACTORY = new MyThreadFactory(); /** * 饱和策略 */ private static final ThreadRejectedExecutionHandler THREAD_REJECTED_EXECUTION_HANDLER = new ThreadRejectedExecutionHandler.CallerRunsPolicy(); /** * 线程池对象 */ private static final ThreadPoolExecutor THREAD_POOL_EXECUTOR; /** * 声明式定义线程池工具类对象静态变量，在所有线程中同步 */ private static volatile ThreadPoolUtils threadPoolUtils = null; /** * 初始化线程池静态代码块 */ static { THREAD_POOL_EXECUTOR = new ThreadPoolExecutor( //核心线程数 CORE_POOL_SIZE, //最大线程数 MAXIMUM_POOL_SIZE, //空闲线程执行时间 KEEP_ALIVE_SECONDS, //空闲线程执行时间单位 TimeUnit.SECONDS, //工作队列（或阻塞队列） POOL_WORK_QUEUE, //工厂模式 MY_THREAD_FACTORY, //饱和策略 THREAD_REJECTED_EXECUTION_HANDLER ); } /** * 线程池工具类空参构造方法 */ private ThreadPoolUtils() {} /** * 获取线程池工具类实例 * @return */ public static ThreadPoolUtils getNewInstance(){ if (threadPoolUtils == null) { synchronized (ThreadPoolUtils.class) { if (threadPoolUtils == null) { threadPoolUtils = new ThreadPoolUtils(); } } } return threadPoolUtils; } /** * 执行线程任务 * @param runnable 任务线程 */ public void executor(Runnable runnable) { THREAD_POOL_EXECUTOR.execute(runnable); } /** * 获取线程池状态 * @return 返回线程池状态 */ public boolean isShutDown(){ return THREAD_POOL_EXECUTOR.isShutdown(); } /** * 停止正在执行的线程任务 * @return 返回等待执行的任务列表 */ public List&lt;Runnable&gt; shutDownNow(){ return THREAD_POOL_EXECUTOR.shutdownNow(); } /** * 关闭线程池 */ public void showDown(){ THREAD_POOL_EXECUTOR.shutdown(); } /** * 关闭线程池后判断所有任务是否都已完成 * @return */ public boolean isTerminated(){ return THREAD_POOL_EXECUTOR.isTerminated(); }} 2.2 ForkJoinPool类继承结构 2.2.1 ForkJoinPool 是什么ForkJoinPool是自java7开始，jvm提供的一个用于并行执行的任务框架。其主旨是将大任务分成若干小任务，之后再并行对这些小任务进行计算，最终汇总这些任务的结果。得到最终的结果。其广泛用在java8的stream中。 2.2.2 分治法 分治法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题的相互独立且与原问题的性质相同，求出子问题的解之后，将这些解合并，就可以得到原有问题的解。是一种分目标完成的程序算法。简单的问题，可以用二分法来完成。 2.2.3 工作窃取 工作窃取是指当某个线程的任务队列中没有可执行任务的时候，从其他线程的任务队列中窃取任务来执行，以充分利用工作线程的计算能力，减少线程由于获取不到任务而造成的空闲浪费。在ForkJoinpool中，工作任务的队列都采用双端队列Deque容器。我们知道，在通常使用队列的过程中，我们都在队尾插入，而在队头消费以实现FIFO。而为了实现工作窃取。一般我们会改成工作线程在工作队列上LIFO,而窃取其他线程的任务的时候，从队列头部取获取 2.2.4 简单使用加法计算 主要逻辑 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.RecursiveTask;public class CountTask extends RecursiveTask&lt;Integer&gt;{ private static final long serialVersionUID = 1L; private static final int THRESHOLD = 49; private int start; private int end; public CountTask(int start, int end) { this.start = start; this.end = end; } @Override protected Integer compute() { if (end - start &lt;= THRESHOLD) { int result = 0; for (int i = start; i &lt;= end; i++) { result += i; } return result; } else { int middle = (start + end) / 2; CountTask firstTask = new CountTask(start, middle); CountTask secondTask = new CountTask(middle + 1, end); invokeAll(firstTask,secondTask); return firstTask.join() + secondTask.join(); } }} 使用调用 123456789101112131415161718192021import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.TimeUnit;public class ForkJoinPoolTest { public static void main(String[] args) throws InterruptedException, ExecutionException { int result1 = 0; for (int i = 1; i &lt;= 1000000; i++) { result1 += i; } System.out.println(&quot;循环计算 1-1000000 累加值：&quot; + result1); ForkJoinPool pool = new ForkJoinPool(); ForkJoinTask&lt;Integer&gt; task = pool.submit(new CountTask(1, 1000000)); int result2 = task.get(); System.out.println(&quot;并行计算 1-1000000 累加值：&quot; + result2); pool.awaitTermination(2, TimeUnit.SECONDS); pool.shutdown(); }}","link":"/2022/04/24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"springcloud","slug":"springcloud","link":"/tags/springcloud/"},{"name":"工具类","slug":"工具类","link":"/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"},{"name":"线程","slug":"线程","link":"/tags/%E7%BA%BF%E7%A8%8B/"}],"categories":[{"name":"202204","slug":"202204","link":"/categories/202204/"}]}