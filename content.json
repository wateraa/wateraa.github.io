{"pages":[],"posts":[{"title":"1. 微服务介绍","text":"微服务介绍 一、为什么要用微服务？ 互联网应用的特点： 需求变化快 用户群体大 二、 什么是微服务？ 简单来说，微服务就是将一种单一应用程序拆分为一组小型服务的方法，拆分完成之后，每一个服务都运行在独立的进程中，服务之间采用轻量级的通信机制来沟通。SpringCloud 中采用基于 HTTP 的 RESTful API 三、微服务的优势 复杂度可控 独立部署 技术选型灵活 较好的容错性 较强的可扩展性 四、 Spring Cloud 核心特性 服务注册与发现 负载均衡 服务之间调用 容错、服务降级、断路器 消息总线 分布式配置中心 链路器","link":"/2022/04/16/1.%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/"},{"title":"2. 服务注册中心","text":"服务注册中心EurekaEureka 是 Spring Cloud 的注册中心，类似 Dubbo 中的 Zookeeper。 到底什么是注册中心？我们为什么要注册中心 在单体应用中, 所有的业务集中在一个项目中，调用过程是一条直线，不需要服务之间的中转，没有必要引入注册中心 项目越来越大，我们会将系统进行拆分。各个模块之间进行协作，模块之间的调用 会变得越来越复杂，模块之间存在强耦合。 为了解决服务之间的耦合，注册中心方案自然就出现了。 基于 REST 来实现服务的注册与发现。 Eureka 是 Spring Cloud最重要的核心组件。 Eureka 提供可视化的页面，可以方便的查看服务注册情况医技服务注册中心集群的运行情况。从图中可以看出,存在3个角色 Eureka Server 注册中心 Eureka Provider 服务提供者 Eureka Consumer 服务消费者 Eureka 环境搭建创建一个普通的 spring boot项目, 添加 Eureka 依赖 项目创建成功之后，在项目启动类上添加注解，表示项目是一个 Eureka Server 12345678910@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); }} 其中 @EnableEurekaServer 注解表示开启 Eureka 功能 123456789# 给单前服务取名spring.application.name=eureka# 端口号server.port=1111# 表示当前项目不要注册到中心上eureka.client.register-with-eureka=false# 表示是否从 Eureka Server 获取注册信息eureka.client.fetch-registry=false 配置完成后就可以启动了 Eureka 集群搭建使用了注册中心之后，所有的服务都需要通过服务注册中心来进行交互。服务的注册中心的稳定性就非常重要了。所以注册中心一般都是集群的形式。 Eureka 集群就是多个 实例，相互注册，互相同步数据，组成集群实例A实例B配置完成后 打包启动A 1java -jar .\\eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=a 启动B 1java -jar .\\eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=b 互相注册成功 Eureka 工作细节本身可以分为2大部分：Eureka Server 和 Eureka Client Eureka Server 服务注册，所有服务都注册到 Eureka Server 上来 提供注册表，注册表是所有注册上来服务的列表，Eureka Client调用服务时,需要获取注册表，一般来说，注册表会缓存下来。 无状态，Eureka Server 通过注册心跳机制，和 Eureka Client同步 客户端状态。 Eureka ClientEureka Client 用来简化 服务和 Eureka Server 之间的交互,自动拉取，更新以及缓存 Eureka Server 的信息。即使 Eureka Server 宕机了，依然能够获取想要调用服务的地址（地址可能不准确） 服务注册所谓 Eureka Server 只是一个业务上划分，其实本身也是一个 Eureka Client 。需要把自身的元数据暴露出去,比如 ip,端口 运行状态等 服务续约默认情况下,服务注册之后，Eureka Client 每隔 30s 就要向 Eureka Server 发送一条心跳消息。Eureka Server 90s 内 没有收到 Eureka Client的消息，就会认为 Eureka Client 下线，会从服务列表中移除。一般不建议修改。 12eureka.instance.lease-renewal-interval-in-seconds=30eureka.instance.lease-expiration-duration-in-seconds=90 服务下线Eureka Client 下线周，会主动发送消息 告诉 Eureka Server ,我要下线了 获取注册表信息Eureka Client 从 Eureka Server 上获取服务注册信息，缓存到本地。数据会定期更新。2个属性 1234# 是否准许获取注册表信息eureka.client.fetch-registry=true# 更新时间间隔eureka.client.registry-fetch-interval-seconds=30 Eureka 集群原理官方架构图 Eureka Server 之间通过 Replicte 同步数据，不同的Eureka Server 不区分主从节点，所有节点平等的。节点之间，通过 servceUrl 互相注册，形成集群 A –&gt; B –&gt; CA 也是 能够和 C同步，不建议","link":"/2022/04/16/2.%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"},{"title":"3. 服务注册与消费","text":"服务注册与消费一、服务注册微服务注册到 Eureka Server 上,这样其他服务需要调用该服务时,只需要从 Eureka Server 上查询服务的信息即可 创建一个 provider 作为服务提供者,创建项目时，选择 Eureka Client 依赖和 WEB依赖。这样服务创建成功后，简单配置一下 就可以使用了 在 propertires 中 配置项目注册地址 123spring.application.name=providerserver.port=1114eureka.client.service-url.defaultZone = http://localhost:1111/eureka 启动 Erueka Server 再启动 provider：注册成功！ 二、服务消费2.1 基本用法在provider 中提供一个 hello 接口 1234567@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;hello provider&quot;; }} 再创建一个 consumer项目，去消费 provider 提供的接口。consumer 只要能够获取到 provider 接口的地址，就需要 再 consumer 中写死地址，意味着服务之间的耦合度太高了 创建 consumer 项目，添加 web 和 eureka client 依赖项目创建后,添加配置信息 123spring.application.name=consumerserver.port=1115eureka.client.service-url.defaultZone = http://localhost:1111/eureka 实际调用写死路径 12345678910111213141516171819202122232425@RestControllerpublic class UseHelloController { @GetMapping(&quot;/hello1&quot;) public String hello1(){ HttpURLConnection con = null; URL url = null; try { url = new URL(&quot;http://localhost:1114/hello&quot;); con = (HttpURLConnection) url.openConnection(); if (con.getResponseCode() == 200) { BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream())); String s = br.readLine(); br.close(); return s; } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return &quot;xxxxxx&quot;; }} 从 Eureka 服务发现中 请求接口 12345678910111213141516171819202122232425262728293031@RestControllerpublic class UseHelloController { @Autowired DiscoveryClient discoveryClient; @GetMapping(&quot;/hello2&quot;) public String hello2(){ List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(&quot;provider&quot;); ServiceInstance instance = list.get(0); String ip = instance.getHost();//ip int port = instance.getPort();//端口 String Url = &quot;http://&quot; + ip + &quot;:&quot; +port + &quot;/hello&quot;; //从服务发现实例中获取地址 HttpURLConnection con = null; URL url = null; try { url = new URL(Url); con = (HttpURLConnection) url.openConnection(); if (con.getResponseCode() == 200) { BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream())); String s = br.readLine(); br.close(); return s; } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return &quot;xxxxxx&quot;; }} 注意 DiscoveryClient 查询的服务列表是一个集合，其中每一个项就是一个服务实例 2.2 升级改造Http 调用, 从 RestTemplate 实现 12345678910111213141516171819@BeanRestTemplate restTemplateOne(){ return new RestTemplate();}@AutowiredRestTemplate restTemplate;@GetMapping(&quot;/hello3&quot;)public String hello3(){ List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(&quot;provider&quot;); ServiceInstance instance = list.get(0); String ip = instance.getHost();//ip int port = instance.getPort();//端口 String Url = &quot;http://&quot; + ip + &quot;:&quot; +port + &quot;/hello&quot;; //从服务发现实例中获取地址 String s = restTemplate.getForObject(Url,String.class); return s;} 接下来 使用 Ribbon 实现负载均衡首先，我们需要给 RestTemplate 添加注解 12345678910111213141516@Bean@LoadBalancedRestTemplate restTemplateTwo(){ return new RestTemplate();}@Autowired@Qualifier(&quot;restTemplateTwo&quot;)RestTemplate restTemplateTwo;@GetMapping(&quot;/hello4&quot;)public String hello4(){ String s = restTemplateTwo.getForObject(&quot;http://provider/hello&quot;,String.class); return s;} 负载均衡时，提供的地址是模糊的地址。不能给具体的地址 会报错。模糊地址会自动被拦截，自动实现负载均衡 三、RestTmplateRestTmplate 是从 sprng 3.0 开始 支持的 http 请求工具。提供常见 REST 请求方法模板：GET POST PUT DELETERestTmplate 实现了 RestOperation 接口，RestOperation定义了 RESTFUL 操作 3.1 GETgetForObject 返回的是一个对象，对象是返回的具体值。3种请求方式 12345678910//1String s = restTemplateOne.getForObject(&quot;http://provider/hello?name={1}&quot;,String.class,&quot;test&quot;);//2Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;name&quot;,&quot;test&quot;);String s1 = restTemplateOne.getForObject(&quot;http://provider/hello?name={name}&quot;,String.class,map);//3String url = &quot;http://provider/hello?name=&quot; + &quot;test&quot;;URI url1 = URI.create(url);String s2 = restTemplateOne.getForObject(url1,String.class); getForEntity 返回是一个 ResponseEntity 3.2 POSTprovider 中提供2个POST接口，同时 POST 请求需要传递 json。需要创建 maven 项目 作为 commons 模块。模块被 provider 和 consummer 共同引用。这样就可以方便传递 JSON了 provider 提供2个 post 接口 12345678910@PostMapping(&quot;/user1&quot;)public User addUser1(User user){//传参是以 key/value return user;}@PostMapping(&quot;/user2&quot;)public User addUser2(@RequestBody User user){//传参是以 json return user;} consumer 调用接口 1234567891011121314151617@GetMapping(&quot;/hello6&quot;) public String hello6(){ //1 key vaues 传递参数 MultiValueMap&lt;String,Object&gt; map = new LinkedMultiValueMap&lt;String,Object&gt;(); map.add(&quot;id&quot;,123); map.add(&quot;username&quot;,&quot;java&quot;); map.add(&quot;password&quot;,&quot;123&quot;); String url = &quot;http://provider/user1&quot;; User user = restTemplateTwo.postForObject(url,map,User.class); System.out.println(user); user.setId(456); String url2 = &quot;http://provider/user2&quot;; //2 json 传递参数 User user1 = restTemplateTwo.postForObject(url2,user,User.class); System.out.println(user1); return &quot;ok!!!&quot;; } 接口调用成功 postForLocation：场景，执行一个 post 请求之后, 马上进行重定向，比如注册完成之后，马上重定向到登录页面登录。http请求状态码 302 provider 提供注册接口,注意这里的post接口 响应码一定是302 不然无效 注意：重定向的地址一定要写成绝对路径，不要写成相对路径，否则调用会出问题，找不到服务实例 123456789101112@Controllerpublic class RegisterController { @PostMapping(&quot;/register&quot;) public String register(User user){ return &quot;redirect:http://provider/loginPage?name=&quot; + user.getUsername(); } @GetMapping(&quot;/loginPage&quot;) @ResponseBody public String loginPage(String name){ return &quot;loginPage:&quot; + name; }} consummer 调用 123456789101112131415@Autowired@Qualifier(&quot;restTemplateTwo&quot;)RestTemplate restTemplateTwo;@GetMapping(&quot;/hello7&quot;)public String hello7(){ String url = &quot;http://provider/register&quot;; MultiValueMap&lt;String,Object&gt; map = new LinkedMultiValueMap&lt;String,Object&gt;(); map.add(&quot;id&quot;,123); map.add(&quot;username&quot;,&quot;java&quot;); map.add(&quot;password&quot;,&quot;123&quot;); URI uri = restTemplateTwo.postForLocation(url,map); String s = restTemplateTwo.getForObject(uri,String.class); return s;} 负载均衡原理 从 Eureka Cilent 本地缓存的服务注册信息中选择一个可以调用的服务 根据选中的服务，重构请求的 URL 地址 最终将功能嵌入到 RestTemplate 中","link":"/2022/04/16/3.%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B6%88%E8%B4%B9/"},{"title":"4. Consul 介绍","text":"Consul注册中心备选方案。Consul主要提供了 服务发现、服务隔离、服务配置等功能相比于 Eureka 和 zookeeper，Consul 配置更加一站式,因为内置了很多微服务的常见的需求：服务发现与注册,分布式一致性协议实现、健康检查、键值对存储、多数据中心等、不在需要第三方组件来实现这些功能。 一、安装Consul使用go 语言开发,需要安装下载 1weget https://releases.hashicorp.com/consul/1.11.4/consul_1.11.4_linux_amd64.zip 安装 直接解压即可 1unzip consul_1.11.4_linux_amd64.zip 启动(开发模式启动,地址是本地虚拟机地址) 1./consul agent -dev -ui -node=consul-dev -client=192.168.10.128 启动成功之后，在物理机可以访问（需要注意端口 8500开放） 二、Consul 使用创建 spring boot 项目添加依赖 开启服务发现功能 123456789@SpringBootApplication@EnableDiscoveryClientpublic class ConsulProviderApplication { public static void main(String[] args) { SpringApplication.run(ConsulProviderApplication.class, args); }} 添加相关consul配置 123456spring.application.name=consul-providerserver.port=2000#consul 相关配置spring.cloud.consul.host=192.168.10.128spring.cloud.consul.port=8500spring.cloud.consul.discovery.service-name=consul-provider 添加测试接口 1234567@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;hello&quot;; }} 项目启动,注册成功 三、Consul 集群使用为了区别增加端口打印 123456789@RestControllerpublic class HelloController { @Value(&quot;${server.port}&quot;) Integer port; @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;hello :&quot; + port; }} 对项目进行打包,在命令行执行命令,启动多个实例 123java -jar .\\consul-provider-0.0.1-SNAPSHOT.jar --server.port=2001java -jar .\\consul-provider-0.0.1-SNAPSHOT.jar --server.port=2000 查看 consul 管理界面，集群注册成功 四、consul 消费搭建环境 consul-consumer 创建成功后，添加一下配置 123456spring.application.name=consul-consumerserver.port=2005#consul 相关配置spring.cloud.consul.host=192.168.10.128spring.cloud.consul.port=8500spring.cloud.consul.discovery.service-name=consul-consumer 开启服务发现 1@EnableDiscoveryClient 提供一个服务调用方法 12345678910111213141516171819@RestControllerpublic class HelloController { @Autowired LoadBalancerClient loadBalancerClient; @Autowired RestTemplate restTemplate; @Bean RestTemplate getRstTemplate(){ return new RestTemplate(); } @GetMapping(&quot;/hello&quot;) public void hello(){ ServiceInstance choose = loadBalancerClient.choose(&quot;consul-provider&quot;); System.out.println(&quot;服务地址&quot; + choose.getUri()); System.out.println(&quot;服务名称&quot; + choose.getServiceId()); String forObject = restTemplate.getForObject(choose.getUri() + &quot;/hello&quot;, String.class); System.out.println(forObject); }}","link":"/2022/04/16/4.%20Consul/"},{"title":"how to push","text":"每篇文章开头附上如下 12345678---title: 标题date: 时间点tags: 标签categories: 分类---截断全文 &lt;!-- more --&gt; ~\\source_posts 在此目录下 写文章 清除缓存 1hexo clean 生成静态文件 发布 12hexo ghexo s 发布到 github 1hexo d","link":"/2022/04/01/How%20to%20push/"},{"title":"String","text":"StringStringBuffer，StringBuilder区别是什么？标准答案：前者线程安全，后者线程不安全。 Java 语言设计之初，就是为了替代（当时）极其复杂原始的C/C++，其中的一个大改进就是，把并发（多线程）的理念贯彻到了语言的各个角落。 例如，当初 Java 设计者将 Java 语言设计成所有对象都支持作为 synchronized 代码块的互斥锁使用，还把 wait、notify 等 final 方法放到万物之源 Object 类。为什么最初几乎所有可变对象如 StringBuffer、Vector、Hashtable、ByteArray{Input,Output}Stream 等都要设计成线程安全的？ 因为当初的语言设计者认为多线程是万金油，这些可变对象几乎都会被多个线程同时修改，所以为了避免 Race Condition，也为了避免程序员频繁使用 synchronized 代码块造成可读性和易用性降低，就把它们统统设计成“线程安全”的，让保持同步的脏活累活都留给标准库干，反正也不影响单线程下的准确性，无非损失亿点性能而已。但事实证明，多个线程同时修改一个对象的场景才是少数，绝大多数可变对象只会被一个线程修改，然而因为频繁不必要的上锁、释放锁的操作，使得性能损失很大，所以你会看到，后来的 ArrayList、HashMap 等可变类都不再默认线程安全，以此换取单线程下的性能提升，然后用 Collections.synchronizedXxx 等方法提供少数情况需要多线程安全的可变对象。 这个问题的主角 StringBuffer 和 StringBuilder 也是一样的，后者就是为纠正历史遗留问题，提高单线程下的性能而生的，而为了向下兼容性和需要线程安全的场景，才保留 StringBuffer 类。 随着内存越来越大，函数式编程的“万物皆 immutable”的思想流行，Java 也出现越来越多的不可变类，例如 java.time 包中的类、Optional 类、 List.of、Set.of 返回的不可变集合等。这才是多进程、多线程下保证准确性、提升性能的新的解决方案。 四个线程安全策略 线程限制1一个被线程限制的对象，由线程独占，只能被线程占有的线程修改 共享只读1在没有额外同步的情况下，可以被多个线程并发访问，不能修改 线程安全对象1一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，所以其他线程无需额外的同步就可以通过公共接口随意访问它 被守护对象1被守护对象只能通过获取特定的锁来访问 不可变对象在Java中，有一种对象发布了就是安全的，被称之为不可变对象。 不可变对象可以在多线程中可以保证线程安全 不可变对象满足的条件 对象创建之后状态就不能修改 对象的域都是 final 类型 对象是正确创建的（对象在创建期间，this引用没有溢出，外部不可见） 创建不可变对象 将类声明成final类型，使其不可以被继承 将所有的成员设置成私有的，使其他的类和对象不能直接访问这些成员 对变量不提供set方法 将所有可变的成员声明为final，这样只能对他们赋值一次 通过构造器初始化所有成员，进行深度拷贝 在get方法中，不直接返回对象本身，而是克隆对象，返回对象的拷贝 JDK中的 Collections.unmodifiableXXX传入的对象一经初始化便无法修改,XXX可表示Collection、List、Set、Map等 Collections.UnmodifiableMap的源码 主要是将一个新的集合所有更新方法变成抛出异常","link":"/2022/04/18/String/"},{"title":"icarus","text":"_config.icarus.yml 相关配置中文详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418# 模板版本version: 4.0.0# Icarus 主题样式，一种默认，一种赛博朋克&quot;default&quot; or &quot;cyberpunk&quot;variant: default# 顶部logo 设置你站点的logo。 此logo会显示在导航栏和页脚。 图片或者是文字logo: https://gitee.com/cnhuashao/picgo-images/raw/master/20210902174326.png# 页面元数据配置head: # 浏览器图标 favicon: https://gitee.com/cnhuashao/picgo-images/raw/master/20210831154758.png # Web应用程序清单配置 Icarus支持基本的PWAmanifest.json的生成与Meta标签 # https://developer.mozilla.org/en-US/docs/Web/Manifest manifest: # web应用程序的名称(默认为站点标题) name: CN華少 # 显示的web应用程序名称 # 当没有足够的空间显示全名时 short_name: CN華少 # web应用程序的起始URL start_url: https://blog.cnhuashao.com # 应用程序的默认主题颜色 theme_color: # 在加载样式表之前，要显示的应用程序页面的占位符背景颜色 background_color: # 网站的首选显示模式 display: standalone # 可以作为不同上下文的应用程序图标的图像文件 icons: - # 映像文件的路径 src: '' # 包含空格分隔的图像维数的字符串 sizes: '' # 关于图像的媒体类型的提示 type: # 打开图元数据 # https://hexo.io/docs/helpers.html#open-graph open_graph: # 页面标题(og:title)(可选) # 你应该在大部分时间里把这个空着 title: CN華少 # 页面类型(og:type)(可选) # 你应该在大部分时间里把这个空着 type: blog # 页面URL (og: URL)(可选) # 你应该在大部分时间里把这个空着 url: https://blog.cnhuashao.com/ # 封面地址 (og:image) (可选) # 你应该在大部分时间里把这个空着 image: https://gitee.com/cnhuashao/picgo-images/raw/master/psc.jpg # 站点名 (og:site_name) (可选) # 你应该在大部分时间里把这个空着 site_name: CN華少 # 创建作者 (article:author) (可选) # 你应该在大部分时间里把这个空着 author: CN華少 # 页面描述 (og:description) (可选) # 你应该在大部分时间里把这个空着 description: # Twitter card type (twitter:card) twitter_card: # Twitter ID (twitter:creator) twitter_id: # Twitter Site (twitter:site) twitter_site: # Google+ profile link (deprecated) google_plus: # Facebook admin ID fb_admins: # Facebook App ID fb_app_id: # 页面的结构化数据 # https://developers.google.com/search/docs/guides/intro-structured-data structured_data: # 页标题 (可选) # 你应该在大部分时间里把这个空着 title: # 页面描述 (可选) # 你应该在大部分时间里把这个空着 description: # 链接页面网址 (可选) # 你应该在大部分时间里把这个空着 url: # 创建作者 (article:author) (可选) # 你应该在大部分时间里把这个空着 author: # 页面的出版商 (可选) # 你应该在大部分时间里把这个空着 publisher: # 页面出版商标志 (可选) # 你应该在大部分时间里把这个空着 publisher_logo: # 页面图片 (可选) # 你应该在大部分时间里把这个空着 image: # 数组中的附加HTML元标记 meta: # Meta tag specified in &lt;attribute&gt;=&lt;value&gt; style # E.g., name=theme-color;content=#123456 =&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#123456&quot;&gt; - '' # 网址或路径到网站的RSS atom.xml rss: atom.xml# 页面顶部导航栏配置navbar: # 导航菜单项 menu: 首页: / 文章归档: /archives 分类: /categories 标签: /tags 个人简介: /about 留言: /message 音乐: /music 媒体: /media # 导航右侧快捷方式 links: Gitee: icon: fab fa-git-square url: 'https://gitee.com/cnhuashao'# 页脚footer: # 右侧超链接设置 links: 知识共享: icon: fab fa-creative-commons url: 'https://creativecommons.org/' CC BY-NC 4.0: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by-nc/4.0/deed.zh' Download on Gitee: icon: fab fa-git-square url: 'https://gitee.com/cnhuashao'# 文章相关配置article: # 代码高亮显示设置 highlight: # 代码高亮显示主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制代码按钮 clipboard: true # 代码块的默认折叠状态。 可以是 &quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 显示文章字数统计以及预计阅读时间。 readtime: true # 文章许可协议 licenses: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by-nc/4.0/' Noncommercial: icon: fab fa-creative-commons-nc url: 'https://creativecommons.org/licenses/by-nc/4.0/'# 搜索插件配置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Search/search: type: insight# 评论插件配置-这里使用的畅言# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Comment/comment: type: changyan # Disqus shortname app_id: conf: # 捐赠插件配置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Donation/donates: # &quot;Afdian.net&quot; 捐赠按钮配置 #- # type: afdian # URL to the &quot;Afdian.net&quot; personal page # url: '' # 支付宝捐赠按钮配置 - type: alipay # Alipay qrcode image URL qrcode: 'https://gitee.com/cnhuashao/picgo-images/raw/master/20210902142707.jpg' # &quot;Buy me a coffee&quot; donate button configurations #- # type: buymeacoffee # URL to the &quot;Buy me a coffee&quot; page # url: '' # Patreon donate button configurations #- # type: patreon # URL to the Patreon page # url: '' # Paypal donate button configurations #- # type: paypal # Paypal business ID or email address # business: '' # Currency code # currency_code: USD # 微信捐赠按钮配置 - type: wechat # Wechat qrcode image URL qrcode: 'https://gitee.com/cnhuashao/picgo-images/raw/master/20210902142706.jpg'# 分享插件配置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Share/share: type: sharethis # URL to the ShareThis share plugin script install_url: ''# 侧边栏的配置。# 请注意，侧边栏只有在至少有一个小部件时才可见sidebar: # 左栏的配置 left: # 当页面滚动时左侧侧边栏是否停留在顶部 sticky: true # Right sidebar configurations right: # Whether the sidebar sticks to the top when page scrolls sticky: true# 布局配置文件遵循着与主题配置文件相同的格式和定义。# _config.post.yml中的配置对所有文章生效，而_config.page.yml中的配置对所有自定义页面生效。# 这两个文件将覆盖主题配置文件中的配置。# 注： 如果想对于文章进行单独设置时，我们就启用_config.post.yml配置文件配置# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: # 个人信息小部件配置 - # 小部件应该放在哪里，左边栏还是右边栏 position: left type: profile # 作者名称 author: CN華少 # 作者标题 author_title: 想做、能做、去做、做到、做好 # 当前位置 location: 中国，山东，济南 # 图像URL avatar: https://gitee.com/cnhuashao/picgo-images/raw/master/psc.jpg # 是否显示圆形头像图像 avatar_rounded: true # Gravatar头像邮箱地址 gravatar: # 关注按钮的URL或路径 follow_link: 'https://github.com/cnHuaShao' # 底部快捷连接配置 social_links: Gitee: icon: fab fa-git-square url: 'https://gitee.com/cnHuaShao' Email: icon: fa fa-envelope url: 'mailto:lz2392504@gmail.com' Weibo: icon: fab fa-weibo url: '' WeiXin: icon: fab fa-weixin url: '' Next: icon: fab fa-dribbble url: 'https://blog.cnhuashao.com/remove.io' RSS: icon: fas fa-rss url: / # 目录 小部件配置 - # 小部件显示位置 position: right type: toc # 是否显示每个标题的索引 index: true # 是否在看不到副标题时折叠副标题 collapsed: true # 标题显示的最高水平 depth: 3 # 链接小部件配置 - # 左边栏还是右边栏 position: left type: links # 站点的名称和url links: Hexo: 'https://hexo.io' Gitee: 'https://gitee.com/cnhuashao' # 分类小部件配置 - # Where should the widget be placed, left sidebar or right sidebar position: right type: categories # 最新文章小部件配置 - # Where should the widget be placed, left sidebar or right sidebar position: left type: recent_posts # 档案小部件的配置 - # Where should the widget be placed, left sidebar or right sidebar position: left type: archives # 标签小部件的配置 - # Where should the widget be placed, left sidebar or right sidebar position: right type: tags # 邮件订阅widget配置 - # Where should the widget be placed, left sidebar or right sidebar position: left type: subscribe_email # Hint text under the email input description: # Feedburner ID feedburner_id: '' # 谷歌AdSense单元配置 - # Where should the widget be placed, left sidebar or right sidebar position: right type: adsense # data-ad-client client_id: '' # data-ad-slot slot_id: '' # Follow.跟进。它的电子邮件订阅小部件配置 - # Where should the widget be placed, left sidebar or right sidebar position: left type: followit # Hint text under the email input description: # Subscription form action URL action_url: '' # Feed claiming verification code verification_code: ''# 插件配置# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/plugins: # 启用页面启动动画 animejs: true # 显示“返回顶部”按钮 back_to_top: true # 百度分析插件设置 # https://tongji.baidu.com baidu_analytics: # Baidu Analytics tracking ID tracking_id: # Bing网站管理员工具插件设置 # https://www.bing.com/toolbox/webmaster/ bing_webmaster: # Bing Webmaster Tools tracking ID in the &lt;meta&gt; tag tracking_id: # 不蒜子网页计数器 # https://busuanzi.ibruce.info busuanzi: false # CNZZ统计 # https://www.umeng.com/web cnzz: # CNZZ tracker id id: # CNZZ website id web_id: # 提醒用户cookies的使用 # https://www.osano.com/cookieconsent/ cookie_consent: # The compliance type. Can be &quot;info&quot;, &quot;opt-in&quot;, or &quot;opt-out&quot; type: info # Theme of the popup. Can be &quot;block&quot;, &quot;edgeless&quot;, or &quot;classic&quot; theme: edgeless # Whether the popup should stay static regardless of the page scrolls static: false # Where on the screen the consent popup should display position: bottom-left # URL to your site's cookie policy policyLink: 'https://www.cookiesandyou.com/' # Enable the lightGallery and Justified Gallery plugins gallery: true # 谷歌分析插件设置 # https://analytics.google.com google_analytics: # Google Analytics tracking ID tracking_id: # Hotjar user feedback plugin # https://www.hotjar.com/ hotjar: # Hotjar site id site_id: # Enable the KaTeX math typesetting support # https://katex.org/ katex: false # Enable the MathJax math typesetting support # https://www.mathjax.org/ mathjax: false # 浏览器升级提醒 # http://outdatedbrowser.com/ outdated_browser: false # 网页载入进度条 progressbar: true # Statcounter statistics # https://statcounter.com/ statcounter: # Statcounter project id project: # Statcounter project security code security: # Twitter conversion tracking plugin settings # https://business.twitter.com/en/help/campaign-measurement-and-analytics/conversion-tracking-for-websites.html twitter_conversion_tracking: # Twitter Pixel ID pixel_id: # CDN 提供商# https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/speed-up-your-site-with-custom-cdn/providers: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: jsdelivr # Name or URL template of the webfont CDN provider fontcdn: google # Name or URL of the fontawesome icon font CDN provider iconcdn: fontawesome","link":"/2022/04/19/icarus%E9%85%8D%E7%BD%AE/"},{"title":"写给自己","text":"hello world !!!!","link":"/2022/04/12/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1/"}],"tags":[{"name":"springcloud","slug":"springcloud","link":"/tags/springcloud/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"202204","slug":"202204","link":"/categories/202204/"}]}