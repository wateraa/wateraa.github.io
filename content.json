{"pages":[],"posts":[{"title":"1. 微服务介绍","text":"微服务介绍 一、为什么要用微服务？ 互联网应用的特点： 需求变化快 用户群体大二、 什么是微服务？ 简单来说，微服务就是将一种单一应用程序拆分为一组小型服务的方法，拆分完成之后，每一个服务都运行在独立的进程中，服务之间采用轻量级的通信机制来沟通。SpringCloud 中采用基于 HTTP 的 RESTful API 三、微服务的优势 复杂度可控 独立部署 技术选型灵活 较好的容错性 较强的可扩展性 四、 Spring Cloud 核心特性 服务注册与发现 负载均衡 服务之间调用 容错、服务降级、断路器 消息总线 分布式配置中心 链路器","link":"/2022/04/16/1.%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/"},{"title":"2. 服务注册中心","text":"服务注册中心EurekaEureka 是 Spring Cloud 的注册中心，类似 Dubbo 中的 Zookeeper。 到底什么是注册中心？我们为什么要注册中心 在单体应用中, 所有的业务集中在一个项目中，调用过程是一条直线，不需要服务之间的中转，没有必要引入注册中心 项目越来越大，我们会将系统进行拆分。各个模块之间进行协作，模块之间的调用 会变得越来越复杂，模块之间存在强耦合。 为了解决服务之间的耦合，注册中心方案自然就出现了。 基于 REST 来实现服务的注册与发现。 Eureka 是 Spring Cloud最重要的核心组件。 Eureka 提供可视化的页面，可以方便的查看服务注册情况医技服务注册中心集群的运行情况。从图中可以看出,存在3个角色 Eureka Server 注册中心 Eureka Provider 服务提供者 Eureka Consumer 服务消费者 Eureka 环境搭建创建一个普通的 spring boot项目, 添加 Eureka 依赖 项目创建成功之后，在项目启动类上添加注解，表示项目是一个 Eureka Server 12345678910@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); }} 其中 @EnableEurekaServer 注解表示开启 Eureka 功能 123456789# 给单前服务取名spring.application.name=eureka# 端口号server.port=1111# 表示当前项目不要注册到中心上eureka.client.register-with-eureka=false# 表示是否从 Eureka Server 获取注册信息eureka.client.fetch-registry=false 配置完成后就可以启动了 Eureka 集群搭建使用了注册中心之后，所有的服务都需要通过服务注册中心来进行交互。服务的注册中心的稳定性就非常重要了。所以注册中心一般都是集群的形式。 Eureka 集群就是多个 实例，相互注册，互相同步数据，组成集群实例A实例B配置完成后 打包启动A 1java -jar .\\eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=a 启动B 1java -jar .\\eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=b 互相注册成功 Eureka 工作细节本身可以分为2大部分：Eureka Server 和 Eureka Client Eureka Server 服务注册，所有服务都注册到 Eureka Server 上来 提供注册表，注册表是所有注册上来服务的列表，Eureka Client调用服务时,需要获取注册表，一般来说，注册表会缓存下来。 无状态，Eureka Server 通过注册心跳机制，和 Eureka Client同步 客户端状态。 Eureka ClientEureka Client 用来简化 服务和 Eureka Server 之间的交互,自动拉取，更新以及缓存 Eureka Server 的信息。即使 Eureka Server 宕机了，依然能够获取想要调用服务的地址（地址可能不准确） 服务注册所谓 Eureka Server 只是一个业务上划分，其实本身也是一个 Eureka Client 。需要把自身的元数据暴露出去,比如 ip,端口 运行状态等 服务续约默认情况下,服务注册之后，Eureka Client 每隔 30s 就要向 Eureka Server 发送一条心跳消息。Eureka Server 90s 内 没有收到 Eureka Client的消息，就会认为 Eureka Client 下线，会从服务列表中移除。一般不建议修改。 12eureka.instance.lease-renewal-interval-in-seconds=30eureka.instance.lease-expiration-duration-in-seconds=90 服务下线Eureka Client 下线周，会主动发送消息 告诉 Eureka Server ,我要下线了 获取注册表信息Eureka Client 从 Eureka Server 上获取服务注册信息，缓存到本地。数据会定期更新。2个属性 1234# 是否准许获取注册表信息eureka.client.fetch-registry=true# 更新时间间隔eureka.client.registry-fetch-interval-seconds=30 Eureka 集群原理官方架构图 Eureka Server 之间通过 Replicte 同步数据，不同的Eureka Server 不区分主从节点，所有节点平等的。节点之间，通过 servceUrl 互相注册，形成集群 A –&gt; B –&gt; CA 也是 能够和 C同步，不建议","link":"/2022/04/16/2.%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"},{"title":"4. Consul 介绍","text":"Consul注册中心备选方案。Consul主要提供了 服务发现、服务隔离、服务配置等功能相比于 Eureka 和 zookeeper，Consul 配置更加一站式,因为内置了很多微服务的常见的需求：服务发现与注册,分布式一致性协议实现、健康检查、键值对存储、多数据中心等、不在需要第三方组件来实现这些功能。 一、安装Consul使用go 语言开发,需要安装下载 1weget https://releases.hashicorp.com/consul/1.11.4/consul_1.11.4_linux_amd64.zip 安装 直接解压即可 1unzip consul_1.11.4_linux_amd64.zip 启动(开发模式启动,地址是本地虚拟机地址) 1./consul agent -dev -ui -node=consul-dev -client=192.168.10.128 启动成功之后，在物理机可以访问（需要注意端口 8500开放） 二、Consul 使用创建 spring boot 项目添加依赖 开启服务发现功能 123456789@SpringBootApplication@EnableDiscoveryClientpublic class ConsulProviderApplication { public static void main(String[] args) { SpringApplication.run(ConsulProviderApplication.class, args); }} 添加相关consul配置 123456spring.application.name=consul-providerserver.port=2000#consul 相关配置spring.cloud.consul.host=192.168.10.128spring.cloud.consul.port=8500spring.cloud.consul.discovery.service-name=consul-provider 添加测试接口 1234567@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;hello&quot;; }} 项目启动,注册成功 三、Consul 集群使用为了区别增加端口打印 123456789@RestControllerpublic class HelloController { @Value(&quot;${server.port}&quot;) Integer port; @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;hello :&quot; + port; }} 对项目进行打包,在命令行执行命令,启动多个实例 123java -jar .\\consul-provider-0.0.1-SNAPSHOT.jar --server.port=2001java -jar .\\consul-provider-0.0.1-SNAPSHOT.jar --server.port=2000 查看 consul 管理界面，集群注册成功 四、consul 消费搭建环境 consul-consumer 创建成功后，添加一下配置 123456spring.application.name=consul-consumerserver.port=2005#consul 相关配置spring.cloud.consul.host=192.168.10.128spring.cloud.consul.port=8500spring.cloud.consul.discovery.service-name=consul-consumer 开启服务发现 1@EnableDiscoveryClient 提供一个服务调用方法 12345678910111213141516171819@RestControllerpublic class HelloController { @Autowired LoadBalancerClient loadBalancerClient; @Autowired RestTemplate restTemplate; @Bean RestTemplate getRstTemplate(){ return new RestTemplate(); } @GetMapping(&quot;/hello&quot;) public void hello(){ ServiceInstance choose = loadBalancerClient.choose(&quot;consul-provider&quot;); System.out.println(&quot;服务地址&quot; + choose.getUri()); System.out.println(&quot;服务名称&quot; + choose.getServiceId()); String forObject = restTemplate.getForObject(choose.getUri() + &quot;/hello&quot;, String.class); System.out.println(forObject); }}","link":"/2022/04/16/4.%20Consul/"},{"title":"3. 服务注册与消费","text":"服务注册与消费一、服务注册微服务注册到 Eureka Server 上,这样其他服务需要调用该服务时,只需要从 Eureka Server 上查询服务的信息即可 创建一个 provider 作为服务提供者,创建项目时，选择 Eureka Client 依赖和 WEB依赖。这样服务创建成功后，简单配置一下 就可以使用了 在 propertires 中 配置项目注册地址 123spring.application.name=providerserver.port=1114eureka.client.service-url.defaultZone = http://localhost:1111/eureka 启动 Erueka Server 再启动 provider：注册成功！ 二、服务消费2.1 基本用法在provider 中提供一个 hello 接口 1234567@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;hello provider&quot;; }} 再创建一个 consumer项目，去消费 provider 提供的接口。consumer 只要能够获取到 provider 接口的地址，就需要 再 consumer 中写死地址，意味着服务之间的耦合度太高了 创建 consumer 项目，添加 web 和 eureka client 依赖项目创建后,添加配置信息 123spring.application.name=consumerserver.port=1115eureka.client.service-url.defaultZone = http://localhost:1111/eureka 实际调用写死路径 12345678910111213141516171819202122232425@RestControllerpublic class UseHelloController { @GetMapping(&quot;/hello1&quot;) public String hello1(){ HttpURLConnection con = null; URL url = null; try { url = new URL(&quot;http://localhost:1114/hello&quot;); con = (HttpURLConnection) url.openConnection(); if (con.getResponseCode() == 200) { BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream())); String s = br.readLine(); br.close(); return s; } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return &quot;xxxxxx&quot;; }} 从 Eureka 服务发现中 请求接口 12345678910111213141516171819202122232425262728293031@RestControllerpublic class UseHelloController { @Autowired DiscoveryClient discoveryClient; @GetMapping(&quot;/hello2&quot;) public String hello2(){ List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(&quot;provider&quot;); ServiceInstance instance = list.get(0); String ip = instance.getHost();//ip int port = instance.getPort();//端口 String Url = &quot;http://&quot; + ip + &quot;:&quot; +port + &quot;/hello&quot;; //从服务发现实例中获取地址 HttpURLConnection con = null; URL url = null; try { url = new URL(Url); con = (HttpURLConnection) url.openConnection(); if (con.getResponseCode() == 200) { BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream())); String s = br.readLine(); br.close(); return s; } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return &quot;xxxxxx&quot;; }} 注意 DiscoveryClient 查询的服务列表是一个集合，其中每一个项就是一个服务实例 2.2 升级改造Http 调用, 从 RestTemplate 实现 12345678910111213141516171819@BeanRestTemplate restTemplateOne(){ return new RestTemplate();}@AutowiredRestTemplate restTemplate;@GetMapping(&quot;/hello3&quot;)public String hello3(){ List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(&quot;provider&quot;); ServiceInstance instance = list.get(0); String ip = instance.getHost();//ip int port = instance.getPort();//端口 String Url = &quot;http://&quot; + ip + &quot;:&quot; +port + &quot;/hello&quot;; //从服务发现实例中获取地址 String s = restTemplate.getForObject(Url,String.class); return s;} 接下来 使用 Ribbon 实现负载均衡首先，我们需要给 RestTemplate 添加注解 12345678910111213141516@Bean@LoadBalancedRestTemplate restTemplateTwo(){ return new RestTemplate();}@Autowired@Qualifier(&quot;restTemplateTwo&quot;)RestTemplate restTemplateTwo;@GetMapping(&quot;/hello4&quot;)public String hello4(){ String s = restTemplateTwo.getForObject(&quot;http://provider/hello&quot;,String.class); return s;} 负载均衡时，提供的地址是模糊的地址。不能给具体的地址 会报错。模糊地址会自动被拦截，自动实现负载均衡 三、RestTmplateRestTmplate 是从 sprng 3.0 开始 支持的 http 请求工具。提供常见 REST 请求方法模板：GET POST PUT DELETERestTmplate 实现了 RestOperation 接口，RestOperation定义了 RESTFUL 操作 3.1 GETgetForObject 返回的是一个对象，对象是返回的具体值。3种请求方式 12345678910//1String s = restTemplateOne.getForObject(&quot;http://provider/hello?name={1}&quot;,String.class,&quot;test&quot;);//2Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;name&quot;,&quot;test&quot;);String s1 = restTemplateOne.getForObject(&quot;http://provider/hello?name={name}&quot;,String.class,map);//3String url = &quot;http://provider/hello?name=&quot; + &quot;test&quot;;URI url1 = URI.create(url);String s2 = restTemplateOne.getForObject(url1,String.class); getForEntity 返回是一个 ResponseEntity 3.2 POSTprovider 中提供2个POST接口，同时 POST 请求需要传递 json。需要创建 maven 项目 作为 commons 模块。模块被 provider 和 consummer 共同引用。这样就可以方便传递 JSON了 provider 提供2个 post 接口 12345678910@PostMapping(&quot;/user1&quot;)public User addUser1(User user){//传参是以 key/value return user;}@PostMapping(&quot;/user2&quot;)public User addUser2(@RequestBody User user){//传参是以 json return user;} consumer 调用接口 1234567891011121314151617@GetMapping(&quot;/hello6&quot;) public String hello6(){ //1 key vaues 传递参数 MultiValueMap&lt;String,Object&gt; map = new LinkedMultiValueMap&lt;String,Object&gt;(); map.add(&quot;id&quot;,123); map.add(&quot;username&quot;,&quot;java&quot;); map.add(&quot;password&quot;,&quot;123&quot;); String url = &quot;http://provider/user1&quot;; User user = restTemplateTwo.postForObject(url,map,User.class); System.out.println(user); user.setId(456); String url2 = &quot;http://provider/user2&quot;; //2 json 传递参数 User user1 = restTemplateTwo.postForObject(url2,user,User.class); System.out.println(user1); return &quot;ok!!!&quot;; } 接口调用成功 postForLocation：场景，执行一个 post 请求之后, 马上进行重定向，比如注册完成之后，马上重定向到登录页面登录。http请求状态码 302 provider 提供注册接口,注意这里的post接口 响应码一定是302 不然无效 注意：重定向的地址一定要写成绝对路径，不要写成相对路径，否则调用会出问题，找不到服务实例 123456789101112@Controllerpublic class RegisterController { @PostMapping(&quot;/register&quot;) public String register(User user){ return &quot;redirect:http://provider/loginPage?name=&quot; + user.getUsername(); } @GetMapping(&quot;/loginPage&quot;) @ResponseBody public String loginPage(String name){ return &quot;loginPage:&quot; + name; }} consummer 调用 123456789101112131415@Autowired@Qualifier(&quot;restTemplateTwo&quot;)RestTemplate restTemplateTwo;@GetMapping(&quot;/hello7&quot;)public String hello7(){ String url = &quot;http://provider/register&quot;; MultiValueMap&lt;String,Object&gt; map = new LinkedMultiValueMap&lt;String,Object&gt;(); map.add(&quot;id&quot;,123); map.add(&quot;username&quot;,&quot;java&quot;); map.add(&quot;password&quot;,&quot;123&quot;); URI uri = restTemplateTwo.postForLocation(url,map); String s = restTemplateTwo.getForObject(uri,String.class); return s;} 负载均衡原理 从 Eureka Cilent 本地缓存的服务注册信息中选择一个可以调用的服务 根据选中的服务，重构请求的 URL 地址 最终将功能嵌入到 RestTemplate 中","link":"/2022/04/16/3.%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%B6%88%E8%B4%B9/"},{"title":"写给自己","text":"hello world !!!!","link":"/2022/04/12/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1/"},{"title":"how to push","text":"每篇文章开头附上如下 123456---title: 标题date: 时间点tags: 标签categories: 分类--- ~\\source_posts 在此目录下 写文章 清除缓存 1hexo clean 生成静态文件 发布 12hexo ghexo s 发布到 github 1hexo d","link":"/2022/04/01/How%20to%20push/"}],"tags":[{"name":"springcloud","slug":"springcloud","link":"/tags/springcloud/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"}],"categories":[{"name":"202204","slug":"202204","link":"/categories/202204/"}]}